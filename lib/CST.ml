(* Generated by ocaml-tree-sitter. *)
(*
   cpp grammar

   entrypoint: translation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type ms_call_modifier = [
    `X___cdecl of Token.t (* "__cdecl" *)
  | `X___clrc of Token.t (* "__clrcall" *)
  | `X___stdc of Token.t (* "__stdcall" *)
  | `X___fast of Token.t (* "__fastcall" *)
  | `X___this of Token.t (* "__thiscall" *)
  | `X___vect of Token.t (* "__vectorcall" *)
]
[@@deriving sexp_of]

type pat_c46d1b2 = Token.t (* pattern #[ 	]*endif *)
[@@deriving sexp_of]

type pat_c3ea183 = Token.t (* pattern #[ 	]*define *)
[@@deriving sexp_of]

type preproc_arg = Token.t
[@@deriving sexp_of]

type anon_choice_DASHDASH_d11def2 = [
    `DASHDASH of Token.t (* "--" *)
  | `PLUSPLUS of Token.t (* "++" *)
]
[@@deriving sexp_of]

type lambda_default_capture = [
    `EQ of Token.t (* "=" *)
  | `AMP of Token.t (* "&" *)
]
[@@deriving sexp_of]

type raw_string_literal = Token.t
[@@deriving sexp_of]

type imm_tok_lpar = Token.t (* "(" *)
[@@deriving sexp_of]

type virtual_specifier = [
    `Final of Token.t (* "final" *)
  | `Over of Token.t (* "override" *)
]
[@@deriving sexp_of]

type primitive_type = Token.t
[@@deriving sexp_of]

type type_qualifier = [
    `Choice_const of [
        `Const of Token.t (* "const" *)
      | `Vola of Token.t (* "volatile" *)
      | `Rest of Token.t (* "restrict" *)
      | `X__Atomic of Token.t (* "_Atomic" *)
    ]
  | `Muta of Token.t (* "mutable" *)
  | `Cons of Token.t (* "constexpr" *)
]
[@@deriving sexp_of]

type pat_bfeb4bb = Token.t (* pattern #[ 	]*elif *)
[@@deriving sexp_of]

type true_ = Token.t
[@@deriving sexp_of]

type false_ = Token.t
[@@deriving sexp_of]

type pat_3df6e71 = Token.t (* pattern #[ 	]*if *)
[@@deriving sexp_of]

type virtual_function_specifier = [ `Virt of Token.t (* "virtual" *) ]
[@@deriving sexp_of]

type imm_tok_pat_36637e2 = Token.t (* pattern "[^\\n']" *)
[@@deriving sexp_of]

type storage_class_specifier = [
    `Extern of Token.t (* "extern" *)
  | `Static of Token.t (* "static" *)
  | `Regi of Token.t (* "register" *)
  | `Inline of Token.t (* "inline" *)
]
[@@deriving sexp_of]

type pat_9d92f6a = Token.t (* pattern #[ 	]*ifndef *)
[@@deriving sexp_of]

type pat_25b90ba = Token.t (* pattern #[ 	]*ifdef *)
[@@deriving sexp_of]

type tok_prec_p1_gt = Token.t
[@@deriving sexp_of]

type anon_choice_DOT_2ad1dab = [
    `DOT of Token.t (* "." *)
  | `DASHGT of Token.t (* "->" *)
]
[@@deriving sexp_of]

type anon_choice_BANG_67174d6 = [
    `BANG of Token.t (* "!" *)
  | `TILDE of Token.t (* "~" *)
  | `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
]
[@@deriving sexp_of]

type escape_sequence = Token.t
[@@deriving sexp_of]

type ms_unaligned_ptr_modifier = [
    `X__unal of Token.t (* "_unaligned" *)
  | `X___unal of Token.t (* "__unaligned" *)
]
[@@deriving sexp_of]

type preproc_directive = Token.t (* pattern #[ \t]*[a-zA-Z]\w* *)
[@@deriving sexp_of]

type system_lib_string = Token.t
[@@deriving sexp_of]

type identifier = Token.t (* pattern [a-zA-Z_]\w* *)
[@@deriving sexp_of]

type number_literal = Token.t
[@@deriving sexp_of]

type anon_choice_type_a2fe5d4 = [
    `Type of Token.t (* "typename" *)
  | `Class of Token.t (* "class" *)
]
[@@deriving sexp_of]

type pat_56631e5 = Token.t (* pattern #[ 	]*else *)
[@@deriving sexp_of]

type anon_choice_public_c9638d9 = [
    `Public of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
]
[@@deriving sexp_of]

type pat_ca8830e = Token.t (* pattern #[ 	]*include *)
[@@deriving sexp_of]

type imm_tok_prec_p1_pat_c7f65b4 = Token.t (* pattern "[^\\\\\"\\n]+" *)
[@@deriving sexp_of]

type operator_name = Token.t
[@@deriving sexp_of]

type anon_choice_AMP_c92c117 = [
    `AMP of Token.t (* "&" *)
  | `AMPAMP of Token.t (* "&&" *)
]
[@@deriving sexp_of]

type anon_choice_pat_25b90ba_4a37f8c = [
    `Pat_25b90ba of pat_25b90ba
  | `Pat_9d92f6a of pat_9d92f6a
]
[@@deriving sexp_of]

type char_literal = (
    [
        `LSQUOT of Token.t (* "L'" *)
      | `USQUOT_d861d39 of Token.t (* "u'" *)
      | `USQUOT_2701bdc of Token.t (* "U'" *)
      | `U8SQUOT of Token.t (* "u8'" *)
      | `SQUOT of Token.t (* "'" *)
    ]
  * [
        `Esc_seq of escape_sequence (*tok*)
      | `Imm_tok_pat_36637e2 of imm_tok_pat_36637e2
    ]
  * Token.t (* "'" *)
)
[@@deriving sexp_of]

type preproc_call = (
    preproc_directive (*tok*)
  * preproc_arg (*tok*) option
  * Token.t (* "\n" *)
)
[@@deriving sexp_of]

type ms_pointer_modifier = [
    `Ms_unal_ptr_modi of ms_unaligned_ptr_modifier (*tok*)
  | `Ms_rest_modi of Token.t (* "__restrict" *)
  | `Ms_unsi_ptr_modi of Token.t (* "__uptr" *)
  | `Ms_signed_ptr_modi of Token.t (* "__sptr" *)
]
[@@deriving sexp_of]

type string_literal = (
    [
        `LDQUOT of Token.t (* "L\"" *)
      | `UDQUOT_c163aae of Token.t (* "u\"" *)
      | `UDQUOT_df3447d of Token.t (* "U\"" *)
      | `U8DQUOT of Token.t (* "u8\"" *)
      | `DQUOT of Token.t (* "\"" *)
    ]
  * [
        `Imm_tok_prec_p1_pat_c7f65b4 of imm_tok_prec_p1_pat_c7f65b4
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)
[@@deriving sexp_of]

type preproc_def = (
    pat_c3ea183
  * identifier (*tok*)
  * preproc_arg (*tok*) option
  * Token.t (* "\n" *)
)
[@@deriving sexp_of]

type preproc_defined = [
    `Defi_LPAR_id_RPAR of (
        Token.t (* "defined" *) * Token.t (* "(" *) * identifier (*tok*)
      * Token.t (* ")" *)
    )
  | `Defi_id of (Token.t (* "defined" *) * identifier (*tok*))
]
[@@deriving sexp_of]

type variadic_declarator = (Token.t (* "..." *) * identifier (*tok*) option)
[@@deriving sexp_of]

type field_designator = (Token.t (* "." *) * identifier (*tok*))
[@@deriving sexp_of]

type variadic_type_parameter_declaration = (
    anon_choice_type_a2fe5d4 (*tok*)
  * Token.t (* "..." *)
  * identifier (*tok*) option
)
[@@deriving sexp_of]

type type_parameter_declaration = (
    anon_choice_type_a2fe5d4 (*tok*)
  * identifier (*tok*) option
)
[@@deriving sexp_of]

type ms_declspec_modifier = (
    Token.t (* "__declspec" *) * Token.t (* "(" *) * identifier (*tok*)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type anon_choice_stmt_id_d3c4b5f = [
    `Id of identifier (*tok*)
  | `DOTDOTDOT of Token.t (* "..." *)
]
[@@deriving sexp_of]

type sized_type_specifier = (
    [
        `Signed of Token.t (* "signed" *)
      | `Unsi of Token.t (* "unsigned" *)
      | `Long of Token.t (* "long" *)
      | `Short of Token.t (* "short" *)
    ]
      list (* one or more *)
  * [ `Id of identifier (*tok*) | `Prim_type of primitive_type (*tok*) ]
      option
)
[@@deriving sexp_of]

type destructor_name = (Token.t (* "~" *) * identifier (*tok*))
[@@deriving sexp_of]

type anon_choice_raw_str_lit_28125b5 = [
    `Raw_str_lit of raw_string_literal (*tok*)
  | `Str_lit of string_literal (*tok*)
]
[@@deriving sexp_of]

type preproc_argument_list = (
    Token.t (* "(" *)
  * (
        preproc_expression (*tok*)
      * (Token.t (* "," *) * preproc_expression (*tok*))
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and preproc_binary_expression = [
    `Prep_exp_PLUS_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "+" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_DASH_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "-" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_STAR_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "*" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_SLASH_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "/" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_PERC_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "%" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_BARBAR_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "||" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_AMPAMP_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "&&" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_BAR_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "|" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_HAT_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "^" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_AMP_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "&" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_EQEQ_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "==" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_BANGEQ_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "!=" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_GT_prep_exp of (
        preproc_expression (*tok*) * Token.t (* ">" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_GTEQ_prep_exp of (
        preproc_expression (*tok*) * Token.t (* ">=" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_LTEQ_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "<=" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_LT_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "<" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_LTLT_prep_exp of (
        preproc_expression (*tok*) * Token.t (* "<<" *)
      * preproc_expression (*tok*)
    )
  | `Prep_exp_GTGT_prep_exp of (
        preproc_expression (*tok*) * Token.t (* ">>" *)
      * preproc_expression (*tok*)
    )
]

and preproc_call_expression = (
    identifier (*tok*) * preproc_argument_list (*tok*)
)

and preproc_expression = [
    `Id of identifier (*tok*)
  | `Prep_call_exp of preproc_call_expression (*tok*)
  | `Num_lit of number_literal (*tok*)
  | `Char_lit of char_literal (*tok*)
  | `Prep_defi of preproc_defined (*tok*)
  | `Prep_un_exp of (
        anon_choice_BANG_67174d6 (*tok*) * preproc_expression (*tok*)
    )
  | `Prep_bin_exp of preproc_binary_expression (*tok*)
  | `Prep_paren_exp of (
        Token.t (* "(" *) * preproc_expression (*tok*) * Token.t (* ")" *)
    )
]
[@@deriving sexp_of]

type variadic_reference_declarator = (
    [ `AMPAMP of Token.t (* "&&" *) | `AMP of Token.t (* "&" *) ]
  * variadic_declarator (*tok*)
)
[@@deriving sexp_of]

type preproc_params = (
    imm_tok_lpar (*tok*)
  * (
        anon_choice_stmt_id_d3c4b5f (*tok*)
      * (Token.t (* "," *) * anon_choice_stmt_id_d3c4b5f (*tok*))
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type anon_choice_stmt_id_efddc5b = [
    `Id of identifier (*tok*)
  | `Op_name of operator_name (*tok*)
  | `Dest_name of destructor_name (*tok*)
]
[@@deriving sexp_of]

type concatenated_string = (
    anon_choice_raw_str_lit_28125b5 (*tok*)
  * anon_choice_raw_str_lit_28125b5 (*tok*) list (* one or more *)
)
[@@deriving sexp_of]

type preproc_include = (
    pat_ca8830e
  * [
        `Str_lit of string_literal (*tok*)
      | `System_lib_str of system_lib_string (*tok*)
      | `Id of identifier (*tok*)
      | `Prep_call_exp of preproc_call_expression (*tok*)
    ]
  * Token.t (* "\n" *)
)
[@@deriving sexp_of]

type preproc_function_def = (
    pat_c3ea183
  * identifier (*tok*)
  * preproc_params (*tok*)
  * preproc_arg (*tok*) option
  * Token.t (* "\n" *)
)
[@@deriving sexp_of]

type abstract_array_declarator = (
    abstract_declarator (*tok*) option
  * Token.t (* "[" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * anon_choice_exp_508611b (*tok*) option
  * Token.t (* "]" *)
)

and abstract_declarator = [
    `Choice_abst_poin_decl of [
        `Abst_poin_decl of abstract_pointer_declarator (*tok*)
      | `Abst_func_decl of abstract_function_declarator (*tok*)
      | `Abst_array_decl of abstract_array_declarator (*tok*)
      | `Abst_paren_decl of abstract_parenthesized_declarator (*tok*)
    ]
  | `Abst_ref_decl of (
        anon_choice_AMP_c92c117 (*tok*)
      * abstract_declarator (*tok*) option
    )
]

and abstract_function_declarator = (
    abstract_declarator (*tok*) option
  * parameter_list (*tok*)
  * [
        `Type_qual of type_qualifier (*tok*)
      | `Noex of noexcept (*tok*)
      | `Throw_spec of throw_specifier (*tok*)
    ]
      list (* zero or more *)
  * trailing_return_type (*tok*) option
)

and abstract_parenthesized_declarator = (
    Token.t (* "(" *) * abstract_declarator (*tok*) * Token.t (* ")" *)
)

and abstract_pointer_declarator = (
    Token.t (* "*" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * abstract_declarator (*tok*) option
)

and alias_declaration = (
    Token.t (* "using" *) * identifier (*tok*) * Token.t (* "=" *)
  * type_descriptor (*tok*) * Token.t (* ";" *)
)

and anon_choice_arg_list_e4b6f8f = [
    `Arg_list of argument_list (*tok*)
  | `Init_list of initializer_list (*tok*)
]

and anon_choice_class_name_d6703e6 = [
    `Class_name of class_name (*tok*)
  | `Opt_class_name_opt_virt_spec_opt_base_class_clause_field_decl_list of (
        class_name (*tok*) option
      * virtual_specifier (*tok*) option
      * base_class_clause (*tok*) option
      * field_declaration_list (*tok*)
    )
]

and anon_choice_comp_stmt_be91723 = [
    `Comp_stmt of compound_statement (*tok*)
  | `Defa_meth_clause of (
        Token.t (* "=" *) * Token.t (* "default" *) * Token.t (* ";" *)
    )
  | `Delete_meth_clause of (
        Token.t (* "=" *) * Token.t (* "delete" *) * Token.t (* ";" *)
    )
]

and anon_choice_decl_f8b0ff3 = [
    `Decl of declarator (*tok*)
  | `Init_decl of init_declarator (*tok*)
]

and anon_choice_exp_3078596 = [
    `Exp of expression (*tok*)
  | `Init_list of initializer_list (*tok*)
]

and anon_choice_exp_508611b = [
    `Exp of expression (*tok*)
  | `STAR of Token.t (* "*" *)
]

and anon_choice_exp_55b4dba = [
    `Exp of expression (*tok*)
  | `Comma_exp of (
        expression (*tok*) * Token.t (* "," *)
      * anon_choice_exp_55b4dba (*tok*)
    )
]

and anon_choice_init_pair_1a6981e = [
    `Init_pair of (
        [
            `Subs_desi of subscript_designator (*tok*)
          | `Field_desi of field_designator (*tok*)
        ]
          list (* one or more *)
      * Token.t (* "=" *)
      * anon_choice_exp_3078596 (*tok*)
    )
  | `Exp of expression (*tok*)
  | `Init_list of initializer_list (*tok*)
]

and anon_choice_param_decl_13b5913 = [
    `Param_decl of parameter_declaration (*tok*)
  | `Opt_param_decl of optional_parameter_declaration (*tok*)
  | `Type_param_decl of type_parameter_declaration (*tok*)
  | `Vari_param_decl of variadic_parameter_declaration (*tok*)
  | `Vari_type_param_decl of variadic_type_parameter_declaration (*tok*)
  | `Opt_type_param_decl of optional_type_parameter_declaration (*tok*)
  | `Temp_temp_param_decl of (
        Token.t (* "template" *)
      * template_parameter_list (*tok*)
      * [
            `Type_param_decl of type_parameter_declaration (*tok*)
          | `Vari_type_param_decl of
              variadic_type_parameter_declaration (*tok*)
          | `Opt_type_param_decl of
              optional_type_parameter_declaration (*tok*)
        ]
    )
]

and anon_choice_param_decl_d9083af = [
    `Param_decl of parameter_declaration (*tok*)
  | `Opt_param_decl of optional_parameter_declaration (*tok*)
  | `Vari_param_decl of variadic_parameter_declaration (*tok*)
  | `DOTDOTDOT of Token.t (* "..." *)
]

and anon_choice_prep_else_8b52b0f = [
    `Prep_else of (pat_56631e5 * translation_unit (*tok*))
  | `Prep_elif of (
        pat_bfeb4bb
      * preproc_expression (*tok*)
      * Token.t (* "\n" *)
      * translation_unit (*tok*)
      * anon_choice_prep_else_8b52b0f (*tok*) option
    )
]

and anon_choice_prep_else_in_field_decl_list_97ea65e = [
    `Prep_else_in_field_decl_list of (
        pat_56631e5
      * field_declaration_list_item (*tok*) list (* zero or more *)
    )
  | `Prep_elif_in_field_decl_list of (
        pat_bfeb4bb
      * preproc_expression (*tok*)
      * Token.t (* "\n" *)
      * field_declaration_list_item (*tok*) list (* zero or more *)
      * anon_choice_prep_else_in_field_decl_list_97ea65e (*tok*) option
    )
]

and anon_choice_stmt_id_ae28a26 = [
    `Id of identifier (*tok*)
  | `Scoped_field_id of (
        anon_choice_stmt_id_ec78ce4 (*tok*) option
      * Token.t (* "::" *)
      * anon_choice_stmt_id_efddc5b (*tok*)
    )
]

and anon_choice_stmt_id_ec78ce4 = [
    `Id of identifier (*tok*)
  | `Temp_type of template_type (*tok*)
  | `Scoped_name_id of scoped_namespace_identifier (*tok*)
]

and anon_choice_stmt_id_f1f5a37 = [
    `Id of identifier (*tok*)
  | `Scoped_id of scoped_identifier (*tok*)
]

and anon_choice_stor_class_spec_5764fed = [
    `Stor_class_spec of storage_class_specifier (*tok*)
  | `Type_qual of type_qualifier (*tok*)
  | `Attr_spec of attribute_specifier (*tok*)
  | `Ms_decl_modi of ms_declspec_modifier (*tok*)
]

and anon_choice_type_desc_4d9cafa = [
    `Type_desc of type_descriptor (*tok*)
  | `Type_param_pack_expa of (type_descriptor (*tok*) * Token.t (* "..." *))
  | `Exp of expression (*tok*)
]

and anon_choice_type_qual_01506e0 = [
    `Type_qual of type_qualifier (*tok*)
  | `Virt_spec of virtual_specifier (*tok*)
  | `Noex of noexcept (*tok*)
  | `Throw_spec of throw_specifier (*tok*)
  | `Trai_ret_type of trailing_return_type (*tok*)
]

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_exp_3078596 (*tok*)
      * (Token.t (* "," *) * anon_choice_exp_3078596 (*tok*))
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and array_declarator = (
    declarator (*tok*)
  * Token.t (* "[" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * anon_choice_exp_508611b (*tok*) option
  * Token.t (* "]" *)
)

and array_field_declarator = (
    field_declarator (*tok*)
  * Token.t (* "[" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * anon_choice_exp_508611b (*tok*) option
  * Token.t (* "]" *)
)

and assignment_expression = (
    assignment_left_expression (*tok*)
  * [
        `EQ of Token.t (* "=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `BAREQ of Token.t (* "|=" *)
    ]
  * expression (*tok*)
)

and assignment_left_expression = [
    `Choice_id of [
        `Id of identifier (*tok*)
      | `Call_exp of call_expression (*tok*)
      | `Field_exp of field_expression (*tok*)
      | `Poin_exp of pointer_expression (*tok*)
      | `Subs_exp of subscript_expression (*tok*)
      | `Paren_exp of parenthesized_expression (*tok*)
    ]
  | `Scoped_name_id of scoped_namespace_identifier (*tok*)
]

and attribute = (
    Token.t (* "[[" *)
  * expression (*tok*)
  * (Token.t (* "," *) * expression (*tok*)) list (* zero or more *)
  * Token.t (* "]]" *)
)

and attribute_specifier = (
    Token.t (* "__attribute__" *) * Token.t (* "(" *) * argument_list (*tok*)
  * Token.t (* ")" *)
)

and base_class_clause = (
    Token.t (* ":" *)
  * anon_choice_public_c9638d9 (*tok*) option
  * class_name (*tok*)
  * Token.t (* "..." *) option
  * (
        Token.t (* "," *)
      * anon_choice_public_c9638d9 (*tok*) option
      * class_name (*tok*)
      * Token.t (* "..." *) option
    )
      list (* zero or more *)
)

and binary_expression = [
    `Exp_PLUS_exp of (
        expression (*tok*) * Token.t (* "+" *) * expression (*tok*)
    )
  | `Exp_DASH_exp of (
        expression (*tok*) * Token.t (* "-" *) * expression (*tok*)
    )
  | `Exp_STAR_exp of (
        expression (*tok*) * Token.t (* "*" *) * expression (*tok*)
    )
  | `Exp_SLASH_exp of (
        expression (*tok*) * Token.t (* "/" *) * expression (*tok*)
    )
  | `Exp_PERC_exp of (
        expression (*tok*) * Token.t (* "%" *) * expression (*tok*)
    )
  | `Exp_BARBAR_exp of (
        expression (*tok*) * Token.t (* "||" *) * expression (*tok*)
    )
  | `Exp_AMPAMP_exp of (
        expression (*tok*) * Token.t (* "&&" *) * expression (*tok*)
    )
  | `Exp_BAR_exp of (
        expression (*tok*) * Token.t (* "|" *) * expression (*tok*)
    )
  | `Exp_HAT_exp of (
        expression (*tok*) * Token.t (* "^" *) * expression (*tok*)
    )
  | `Exp_AMP_exp of (
        expression (*tok*) * Token.t (* "&" *) * expression (*tok*)
    )
  | `Exp_EQEQ_exp of (
        expression (*tok*) * Token.t (* "==" *) * expression (*tok*)
    )
  | `Exp_BANGEQ_exp of (
        expression (*tok*) * Token.t (* "!=" *) * expression (*tok*)
    )
  | `Exp_GT_exp of (
        expression (*tok*) * Token.t (* ">" *) * expression (*tok*)
    )
  | `Exp_GTEQ_exp of (
        expression (*tok*) * Token.t (* ">=" *) * expression (*tok*)
    )
  | `Exp_LTEQ_exp of (
        expression (*tok*) * Token.t (* "<=" *) * expression (*tok*)
    )
  | `Exp_LT_exp of (
        expression (*tok*) * Token.t (* "<" *) * expression (*tok*)
    )
  | `Exp_LTLT_exp of (
        expression (*tok*) * Token.t (* "<<" *) * expression (*tok*)
    )
  | `Exp_GTGT_exp of (
        expression (*tok*) * Token.t (* ">>" *) * expression (*tok*)
    )
]

and bitfield_clause = (Token.t (* ":" *) * expression (*tok*))

and call_expression = [
    `Exp_arg_list of (expression (*tok*) * argument_list (*tok*))
  | `Prim_type_arg_list of (primitive_type (*tok*) * argument_list (*tok*))
]

and case_statement = (
    [
        `Case_exp of (Token.t (* "case" *) * expression (*tok*))
      | `Defa of Token.t (* "default" *)
    ]
  * Token.t (* ":" *)
  * [
        `Choice_labe_stmt of non_case_statement (*tok*)
      | `Decl of declaration (*tok*)
      | `Type_defi of type_definition (*tok*)
    ]
      list (* zero or more *)
)

and cast_expression = (
    Token.t (* "(" *) * type_descriptor (*tok*) * Token.t (* ")" *)
  * expression (*tok*)
)

and catch_clause = (
    Token.t (* "catch" *) * parameter_list (*tok*)
  * compound_statement (*tok*)
)

and class_name = [
    `Id of identifier (*tok*)
  | `Scoped_type_id of scoped_type_identifier (*tok*)
  | `Temp_type of template_type (*tok*)
]

and compound_literal_expression = [
    `LPAR_type_desc_RPAR_init_list of (
        Token.t (* "(" *) * type_descriptor (*tok*) * Token.t (* ")" *)
      * initializer_list (*tok*)
    )
  | `Choice_id_init_list of (
        [
            `Id of identifier (*tok*)
          | `Temp_type of template_type (*tok*)
          | `Scoped_type_id of scoped_type_identifier (*tok*)
        ]
      * initializer_list (*tok*)
    )
]

and compound_statement = (
    Token.t (* "{" *) * translation_unit (*tok*) * Token.t (* "}" *)
)

and condition_clause = (
    Token.t (* "(" *)
  * [
        `Opt_choice_decl_choice_exp of (
            [
                `Decl of declaration (*tok*)
              | `Exp_stmt of expression_statement (*tok*)
            ]
              option
          * anon_choice_exp_55b4dba (*tok*)
        )
      | `Cond_decl of condition_declaration (*tok*)
    ]
  * Token.t (* ")" *)
)

and condition_declaration = (
    declaration_specifiers (*tok*)
  * declarator (*tok*)
  * [
        `EQ_exp of (Token.t (* "=" *) * expression (*tok*))
      | `Init_list of initializer_list (*tok*)
    ]
)

and conditional_expression = (
    expression (*tok*) * Token.t (* "?" *) * expression (*tok*)
  * Token.t (* ":" *) * expression (*tok*)
)

and constructor_or_destructor_declaration = (
    constructor_specifiers (*tok*) option
  * function_declarator (*tok*)
  * Token.t (* ";" *)
)

and constructor_or_destructor_definition = (
    constructor_specifiers (*tok*) option
  * function_declarator (*tok*)
  * field_initializer_list (*tok*) option
  * anon_choice_comp_stmt_be91723 (*tok*)
)

and constructor_specifiers =
  [
      `Stor_class_spec of storage_class_specifier (*tok*)
    | `Type_qual of type_qualifier (*tok*)
    | `Attr_spec of attribute_specifier (*tok*)
    | `Virt_func_spec of virtual_function_specifier (*tok*)
    | `Expl_func_spec of explicit_function_specifier (*tok*)
  ]
    list (* one or more *)

and declaration = (
    attribute (*tok*) list (* zero or more *)
  * declaration_specifiers (*tok*)
  * anon_choice_decl_f8b0ff3 (*tok*)
  * (Token.t (* "," *) * anon_choice_decl_f8b0ff3 (*tok*))
      list (* zero or more *)
  * Token.t (* ";" *)
)

and declaration_list = (
    Token.t (* "{" *) * translation_unit (*tok*) * Token.t (* "}" *)
)

and declaration_specifiers = (
    anon_choice_stor_class_spec_5764fed (*tok*) list (* zero or more *)
  * type_specifier (*tok*)
  * anon_choice_stor_class_spec_5764fed (*tok*) list (* zero or more *)
)

and declarator = [
    `Choice_poin_decl of [
        `Poin_decl of pointer_declarator (*tok*)
      | `Func_decl of function_declarator (*tok*)
      | `Array_decl of array_declarator (*tok*)
      | `Paren_decl of parenthesized_declarator (*tok*)
      | `Id of identifier (*tok*)
    ]
  | `Ref_decl of (anon_choice_AMP_c92c117 (*tok*) * declarator (*tok*))
  | `Scoped_id of scoped_identifier (*tok*)
  | `Temp_func of template_function (*tok*)
  | `Op_name of operator_name (*tok*)
  | `Dest_name of destructor_name (*tok*)
  | `Stru_bind_decl of (
        Token.t (* "[" *)
      * identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
      * Token.t (* "]" *)
    )
]

and empty_declaration = (type_specifier (*tok*) * Token.t (* ";" *))

and enum_base_clause = (
    Token.t (* ":" *)
  * [
        `Scoped_type_id of scoped_type_identifier (*tok*)
      | `Id of identifier (*tok*)
      | `Sized_type_spec of sized_type_specifier (*tok*)
    ]
)

and enumerator = (
    identifier (*tok*)
  * (Token.t (* "=" *) * expression (*tok*)) option
)

and enumerator_list = (
    Token.t (* "{" *)
  * (
        enumerator (*tok*)
      * (Token.t (* "," *) * enumerator (*tok*)) list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and explicit_function_specifier = [
    `Expl of Token.t (* "explicit" *)
  | `Expl_LPAR_exp_RPAR of (
        Token.t (* "explicit" *) * Token.t (* "(" *) * expression (*tok*)
      * Token.t (* ")" *)
    )
]

and expression = [
    `Choice_cond_exp of [
        `Cond_exp of conditional_expression (*tok*)
      | `Assign_exp of assignment_expression (*tok*)
      | `Bin_exp of binary_expression (*tok*)
      | `Un_exp of unary_expression (*tok*)
      | `Update_exp of update_expression (*tok*)
      | `Cast_exp of cast_expression (*tok*)
      | `Poin_exp of pointer_expression (*tok*)
      | `Sizeof_exp of sizeof_expression (*tok*)
      | `Subs_exp of subscript_expression (*tok*)
      | `Call_exp of call_expression (*tok*)
      | `Field_exp of field_expression (*tok*)
      | `Comp_lit_exp of compound_literal_expression (*tok*)
      | `Id of identifier (*tok*)
      | `Num_lit of number_literal (*tok*)
      | `Str_lit of string_literal (*tok*)
      | `True of true_ (*tok*)
      | `False of false_ (*tok*)
      | `Null of Token.t (* "NULL" *)
      | `Conc_str of concatenated_string (*tok*)
      | `Char_lit of char_literal (*tok*)
      | `Paren_exp of parenthesized_expression (*tok*)
    ]
  | `Temp_func of template_function (*tok*)
  | `Scoped_id of scoped_identifier (*tok*)
  | `New_exp of (
        Token.t (* "::" *) option
      * Token.t (* "new" *)
      * argument_list (*tok*) option
      * type_specifier (*tok*)
      * new_declarator (*tok*) option
      * anon_choice_arg_list_e4b6f8f (*tok*) option
    )
  | `Delete_exp of (
        Token.t (* "::" *) option
      * Token.t (* "delete" *)
      * (Token.t (* "[" *) * Token.t (* "]" *)) option
      * expression (*tok*)
    )
  | `Lambda_exp of (
        lambda_capture_specifier (*tok*)
      * abstract_function_declarator (*tok*) option
      * compound_statement (*tok*)
    )
  | `Param_pack_expa of (expression (*tok*) * Token.t (* "..." *))
  | `Null of Token.t (* "nullptr" *)
  | `This of Token.t (* "this" *)
  | `Raw_str_lit of raw_string_literal (*tok*)
]

and expression_statement = (
    anon_choice_exp_55b4dba (*tok*) option
  * Token.t (* ";" *)
)

and field_declaration = (
    attribute (*tok*) list (* zero or more *)
  * virtual_function_specifier (*tok*) option
  * declaration_specifiers (*tok*)
  * (
        field_declarator (*tok*)
      * (Token.t (* "," *) * field_declarator (*tok*))
          list (* zero or more *)
    )
      option
  * [
        `Bitf_clause of bitfield_clause (*tok*)
      | `Init_list of initializer_list (*tok*)
      | `EQ_choice_exp of (
            Token.t (* "=" *) * anon_choice_exp_3078596 (*tok*)
        )
    ]
      option
  * Token.t (* ";" *)
)

and field_declaration_list = (
    Token.t (* "{" *)
  * field_declaration_list_item (*tok*) list (* zero or more *)
  * Token.t (* "}" *)
)

and field_declaration_list_item = [
    `Choice_field_decl of [
        `Field_decl of field_declaration (*tok*)
      | `Prep_def of preproc_def (*tok*)
      | `Prep_func_def of preproc_function_def (*tok*)
      | `Prep_call of preproc_call (*tok*)
      | `Prep_if_in_field_decl_list of
          preproc_if_in_field_declaration_list (*tok*)
      | `Prep_ifdef_in_field_decl_list of
          preproc_ifdef_in_field_declaration_list (*tok*)
    ]
  | `Temp_decl of template_declaration (*tok*)
  | `Inline_meth_defi of (
        attribute (*tok*) list (* zero or more *)
      * virtual_function_specifier (*tok*) option
      * declaration_specifiers (*tok*)
      * field_declarator (*tok*)
      * anon_choice_comp_stmt_be91723 (*tok*)
    )
  | `Cons_or_dest_defi of constructor_or_destructor_definition (*tok*)
  | `Cons_or_dest_decl of constructor_or_destructor_declaration (*tok*)
  | `Op_cast_defi of operator_cast_definition (*tok*)
  | `Op_cast_decl of operator_cast_declaration (*tok*)
  | `Friend_decl of (
        Token.t (* "friend" *)
      * [
            `Decl of declaration (*tok*)
          | `Func_defi of function_definition (*tok*)
          | `Opt_choice_class_class_name_SEMI of (
                [
                    `Class of Token.t (* "class" *)
                  | `Struct of Token.t (* "struct" *)
                  | `Union of Token.t (* "union" *)
                ]
                  option
              * class_name (*tok*)
              * Token.t (* ";" *)
            )
        ]
    )
  | `Access_spec of (anon_choice_public_c9638d9 (*tok*) * Token.t (* ":" *))
  | `Alias_decl of alias_declaration (*tok*)
  | `Using_decl of using_declaration (*tok*)
  | `Type_defi of type_definition (*tok*)
  | `Static_assert_decl of static_assert_declaration (*tok*)
]

and field_declarator = [
    `Choice_poin_field_decl of [
        `Poin_field_decl of pointer_field_declarator (*tok*)
      | `Func_field_decl of function_field_declarator (*tok*)
      | `Array_field_decl of array_field_declarator (*tok*)
      | `Paren_field_decl of parenthesized_field_declarator (*tok*)
      | `Id of identifier (*tok*)
    ]
  | `Ref_field_decl of (
        anon_choice_AMP_c92c117 (*tok*) * field_declarator (*tok*)
    )
  | `Temp_meth of template_method (*tok*)
  | `Op_name of operator_name (*tok*)
]

and field_expression = [
    `Exp_choice_DOT_id of (
        expression (*tok*) * anon_choice_DOT_2ad1dab (*tok*)
      * identifier (*tok*)
    )
  | `Exp_choice_DOT_choice_dest_name of (
        expression (*tok*)
      * anon_choice_DOT_2ad1dab (*tok*)
      * [
            `Dest_name of destructor_name (*tok*)
          | `Temp_meth of template_method (*tok*)
        ]
    )
]

and field_initializer = (
    anon_choice_stmt_id_ae28a26 (*tok*)
  * [
        `Init_list of initializer_list (*tok*)
      | `Arg_list of argument_list (*tok*)
    ]
  * Token.t (* "..." *) option
)

and field_initializer_list = (
    Token.t (* ":" *)
  * field_initializer (*tok*)
  * (Token.t (* "," *) * field_initializer (*tok*)) list (* zero or more *)
)

and function_declarator = (
    declarator (*tok*)
  * parameter_list (*tok*)
  * attribute_specifier (*tok*) list (* zero or more *)
  * anon_choice_type_qual_01506e0 (*tok*) list (* zero or more *)
)

and function_definition = (
    attribute (*tok*) list (* zero or more *)
  * ms_call_modifier (*tok*) option
  * declaration_specifiers (*tok*)
  * declarator (*tok*)
  * compound_statement (*tok*)
)

and function_field_declarator = (
    field_declarator (*tok*)
  * parameter_list (*tok*)
  * anon_choice_type_qual_01506e0 (*tok*) list (* zero or more *)
)

and init_declarator = [
    `Decl_EQ_choice_init_list of (
        declarator (*tok*)
      * Token.t (* "=" *)
      * [
            `Init_list of initializer_list (*tok*)
          | `Exp of expression (*tok*)
        ]
    )
  | `Decl_choice_arg_list of (
        declarator (*tok*) * anon_choice_arg_list_e4b6f8f (*tok*)
    )
]

and initializer_list = (
    Token.t (* "{" *)
  * (
        anon_choice_init_pair_1a6981e (*tok*)
      * (Token.t (* "," *) * anon_choice_init_pair_1a6981e (*tok*))
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and lambda_capture_specifier = (
    Token.t (* "[" *)
  * [
        `Lambda_defa_capt of lambda_default_capture (*tok*)
      | `Opt_exp_rep_COMMA_exp of
          (
              expression (*tok*)
            * (Token.t (* "," *) * expression (*tok*))
                list (* zero or more *)
          )
            option
      | `Lambda_defa_capt_COMMA_exp_rep_COMMA_exp of (
            lambda_default_capture (*tok*)
          * Token.t (* "," *)
          * expression (*tok*)
          * (Token.t (* "," *) * expression (*tok*)) list (* zero or more *)
        )
    ]
  * Token.t (* "]" *)
)

and linkage_specification = (
    Token.t (* "extern" *)
  * string_literal (*tok*)
  * [
        `Func_defi of function_definition (*tok*)
      | `Decl of declaration (*tok*)
      | `Decl_list of declaration_list (*tok*)
    ]
)

and ms_based_modifier = (Token.t (* "__based" *) * argument_list (*tok*))

and new_declarator = [
  `Rectype of (
      Token.t (* "[" *)
    * expression (*tok*)
    * Token.t (* "]" *)
    * new_declarator (*tok*) option
  )
]

and noexcept = (
    Token.t (* "noexcept" *)
  * (Token.t (* "(" *) * expression (*tok*) option * Token.t (* ")" *))
      option
)

and non_case_statement = [
    `Labe_stmt of (
        identifier (*tok*) * Token.t (* ":" *) * statement (*tok*)
    )
  | `Comp_stmt of compound_statement (*tok*)
  | `Exp_stmt of expression_statement (*tok*)
  | `If_stmt of (
        Token.t (* "if" *)
      * Token.t (* "constexpr" *) option
      * condition_clause (*tok*)
      * statement (*tok*)
      * (Token.t (* "else" *) * statement (*tok*)) option
    )
  | `Switch_stmt of (
        Token.t (* "switch" *) * condition_clause (*tok*)
      * compound_statement (*tok*)
    )
  | `Do_stmt of (
        Token.t (* "do" *) * statement (*tok*) * Token.t (* "while" *)
      * parenthesized_expression (*tok*) * Token.t (* ";" *)
    )
  | `While_stmt of (
        Token.t (* "while" *) * condition_clause (*tok*) * statement (*tok*)
    )
  | `For_stmt of (
        Token.t (* "for" *)
      * Token.t (* "(" *)
      * [
            `Decl of declaration (*tok*)
          | `Opt_choice_exp_SEMI of expression_statement (*tok*)
        ]
      * expression (*tok*) option
      * Token.t (* ";" *)
      * anon_choice_exp_55b4dba (*tok*) option
      * Token.t (* ")" *)
      * statement (*tok*)
    )
  | `Ret_stmt of return_statement (*tok*)
  | `Brk_stmt of (Token.t (* "break" *) * Token.t (* ";" *))
  | `Cont_stmt of (Token.t (* "continue" *) * Token.t (* ";" *))
  | `Goto_stmt of (
        Token.t (* "goto" *) * identifier (*tok*) * Token.t (* ";" *)
    )
]

and operator_cast = (
    (anon_choice_stmt_id_ec78ce4 (*tok*) option * Token.t (* "::" *)) option
  * Token.t (* "operator" *)
  * declaration_specifiers (*tok*)
  * abstract_declarator (*tok*)
)

and operator_cast_declaration = (
    constructor_specifiers (*tok*) option
  * operator_cast (*tok*)
  * (Token.t (* "=" *) * expression (*tok*)) option
  * Token.t (* ";" *)
)

and operator_cast_definition = (
    constructor_specifiers (*tok*) option
  * operator_cast (*tok*)
  * anon_choice_comp_stmt_be91723 (*tok*)
)

and optional_parameter_declaration = (
    declaration_specifiers (*tok*)
  * declarator (*tok*) option
  * Token.t (* "=" *)
  * expression (*tok*)
)

and optional_type_parameter_declaration = (
    anon_choice_type_a2fe5d4 (*tok*)
  * identifier (*tok*) option
  * Token.t (* "=" *)
  * type_specifier (*tok*)
)

and parameter_declaration = (
    attribute (*tok*) list (* zero or more *)
  * declaration_specifiers (*tok*)
  * [
        `Decl of declarator (*tok*)
      | `Abst_decl of abstract_declarator (*tok*)
    ]
      option
)

and parameter_list = (
    Token.t (* "(" *)
  * (
        anon_choice_param_decl_d9083af (*tok*)
      * (Token.t (* "," *) * anon_choice_param_decl_d9083af (*tok*))
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and parenthesized_declarator = (
    Token.t (* "(" *) * declarator (*tok*) * Token.t (* ")" *)
)

and parenthesized_expression = (
    Token.t (* "(" *) * anon_choice_exp_55b4dba (*tok*) * Token.t (* ")" *)
)

and parenthesized_field_declarator = (
    Token.t (* "(" *) * field_declarator (*tok*) * Token.t (* ")" *)
)

and pointer_declarator = (
    ms_based_modifier (*tok*) option
  * Token.t (* "*" *)
  * ms_pointer_modifier (*tok*) list (* zero or more *)
  * type_qualifier (*tok*) list (* zero or more *)
  * declarator (*tok*)
)

and pointer_expression = (
    [ `STAR of Token.t (* "*" *) | `AMP of Token.t (* "&" *) ]
  * expression (*tok*)
)

and pointer_field_declarator = (
    ms_based_modifier (*tok*) option
  * Token.t (* "*" *)
  * ms_pointer_modifier (*tok*) list (* zero or more *)
  * type_qualifier (*tok*) list (* zero or more *)
  * field_declarator (*tok*)
)

and preproc_if = (
    pat_3df6e71
  * preproc_expression (*tok*)
  * Token.t (* "\n" *)
  * translation_unit (*tok*)
  * anon_choice_prep_else_8b52b0f (*tok*) option
  * pat_c46d1b2
)

and preproc_if_in_field_declaration_list = (
    pat_3df6e71
  * preproc_expression (*tok*)
  * Token.t (* "\n" *)
  * field_declaration_list_item (*tok*) list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e (*tok*) option
  * pat_c46d1b2
)

and preproc_ifdef = (
    anon_choice_pat_25b90ba_4a37f8c (*tok*)
  * identifier (*tok*)
  * translation_unit (*tok*)
  * anon_choice_prep_else_8b52b0f (*tok*) option
  * pat_c46d1b2
)

and preproc_ifdef_in_field_declaration_list = (
    anon_choice_pat_25b90ba_4a37f8c (*tok*)
  * identifier (*tok*)
  * field_declaration_list_item (*tok*) list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e (*tok*) option
  * pat_c46d1b2
)

and return_statement = [
    `Ret_opt_choice_exp_SEMI of (
        Token.t (* "return" *)
      * anon_choice_exp_55b4dba (*tok*) option
      * Token.t (* ";" *)
    )
  | `Ret_init_list_SEMI of (
        Token.t (* "return" *) * initializer_list (*tok*) * Token.t (* ";" *)
    )
]

and scoped_identifier = (
    anon_choice_stmt_id_ec78ce4 (*tok*) option
  * Token.t (* "::" *)
  * anon_choice_stmt_id_efddc5b (*tok*)
)

and scoped_namespace_identifier = (
    anon_choice_stmt_id_ec78ce4 (*tok*) option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and scoped_type_identifier = (
    anon_choice_stmt_id_ec78ce4 (*tok*) option
  * Token.t (* "::" *)
  * identifier (*tok*)
)

and sizeof_expression = [
    `Sizeof_choice_exp of (
        Token.t (* "sizeof" *)
      * [
            `Exp of expression (*tok*)
          | `LPAR_type_desc_RPAR of (
                Token.t (* "(" *) * type_descriptor (*tok*)
              * Token.t (* ")" *)
            )
        ]
    )
  | `Sizeof_DOTDOTDOT_LPAR_id_RPAR of (
        Token.t (* "sizeof" *) * Token.t (* "..." *) * Token.t (* "(" *)
      * identifier (*tok*) * Token.t (* ")" *)
    )
]

and statement = [
    `Choice_case_stmt of [
        `Case_stmt of case_statement (*tok*)
      | `Choice_labe_stmt of non_case_statement (*tok*)
    ]
  | `For_range_loop of (
        Token.t (* "for" *) * Token.t (* "(" *)
      * declaration_specifiers (*tok*) * declarator (*tok*)
      * Token.t (* ":" *) * anon_choice_exp_3078596 (*tok*)
      * Token.t (* ")" *) * statement (*tok*)
    )
  | `Try_stmt of (
        Token.t (* "try" *)
      * compound_statement (*tok*)
      * catch_clause (*tok*) list (* one or more *)
    )
  | `Throw_stmt of (
        Token.t (* "throw" *)
      * expression (*tok*) option
      * Token.t (* ";" *)
    )
]

and static_assert_declaration = (
    Token.t (* "static_assert" *)
  * Token.t (* "(" *)
  * expression (*tok*)
  * (
        Token.t (* "," *)
      * [
            `Str_lit of string_literal (*tok*)
          | `Raw_str_lit of raw_string_literal (*tok*)
          | `Conc_str of concatenated_string (*tok*)
        ]
    )
      option
  * Token.t (* ")" *)
  * Token.t (* ";" *)
)

and subscript_designator = (
    Token.t (* "[" *) * expression (*tok*) * Token.t (* "]" *)
)

and subscript_expression = (
    expression (*tok*) * Token.t (* "[" *) * expression (*tok*)
  * Token.t (* "]" *)
)

and template_argument_list = (
    Token.t (* "<" *)
  * (
        anon_choice_type_desc_4d9cafa (*tok*)
      * (Token.t (* "," *) * anon_choice_type_desc_4d9cafa (*tok*))
          list (* zero or more *)
    )
      option
  * tok_prec_p1_gt (*tok*)
)

and template_declaration = (
    Token.t (* "template" *)
  * template_parameter_list (*tok*)
  * [
        `Empty_decl of empty_declaration (*tok*)
      | `Alias_decl of alias_declaration (*tok*)
      | `Decl of declaration (*tok*)
      | `Temp_decl of template_declaration (*tok*)
      | `Func_defi of function_definition (*tok*)
      | `Cons_or_dest_decl of constructor_or_destructor_declaration (*tok*)
      | `Cons_or_dest_defi of constructor_or_destructor_definition (*tok*)
      | `Op_cast_decl of operator_cast_declaration (*tok*)
      | `Op_cast_defi of operator_cast_definition (*tok*)
    ]
)

and template_function = (
    anon_choice_stmt_id_f1f5a37 (*tok*) * template_argument_list (*tok*)
)

and template_method = (
    anon_choice_stmt_id_ae28a26 (*tok*) * template_argument_list (*tok*)
)

and template_parameter_list = (
    Token.t (* "<" *)
  * (
        anon_choice_param_decl_13b5913 (*tok*)
      * (Token.t (* "," *) * anon_choice_param_decl_13b5913 (*tok*))
          list (* zero or more *)
    )
      option
  * tok_prec_p1_gt (*tok*)
)

and template_type = (
    [
        `Id of identifier (*tok*)
      | `Scoped_type_id of scoped_type_identifier (*tok*)
    ]
  * template_argument_list (*tok*)
)

and throw_specifier = (
    Token.t (* "throw" *)
  * Token.t (* "(" *)
  * (
        type_descriptor (*tok*)
      * (Token.t (* "," *) * type_descriptor (*tok*)) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and top_level_item = [
    `Choice_func_defi of [
        `Func_defi of function_definition (*tok*)
      | `Link_spec of linkage_specification (*tok*)
      | `Decl of declaration (*tok*)
      | `Choice_choice_case_stmt of statement (*tok*)
      | `Type_defi of type_definition (*tok*)
      | `Empty_decl of empty_declaration (*tok*)
      | `Prep_if of preproc_if (*tok*)
      | `Prep_ifdef of preproc_ifdef (*tok*)
      | `Prep_incl of preproc_include (*tok*)
      | `Prep_def of preproc_def (*tok*)
      | `Prep_func_def of preproc_function_def (*tok*)
      | `Prep_call of preproc_call (*tok*)
    ]
  | `Name_defi of (
        Token.t (* "namespace" *)
      * identifier (*tok*) option
      * declaration_list (*tok*)
    )
  | `Using_decl of using_declaration (*tok*)
  | `Alias_decl of alias_declaration (*tok*)
  | `Static_assert_decl of static_assert_declaration (*tok*)
  | `Temp_decl of template_declaration (*tok*)
  | `Temp_inst of (
        Token.t (* "template" *)
      * declaration_specifiers (*tok*) option
      * declarator (*tok*)
      * Token.t (* ";" *)
    )
  | `Cons_or_dest_defi of constructor_or_destructor_definition (*tok*)
  | `Op_cast_defi of operator_cast_definition (*tok*)
  | `Op_cast_decl of operator_cast_declaration (*tok*)
]

and trailing_return_type = (
    Token.t (* "->" *)
  * type_qualifier (*tok*) option
  * type_specifier (*tok*)
  * abstract_declarator (*tok*) option
)

and translation_unit = top_level_item (*tok*) list (* zero or more *)

and type_declarator = [
    `Poin_type_decl of (
        ms_based_modifier (*tok*) option
      * Token.t (* "*" *)
      * ms_pointer_modifier (*tok*) list (* zero or more *)
      * type_qualifier (*tok*) list (* zero or more *)
      * type_declarator (*tok*)
    )
  | `Func_type_decl of (type_declarator (*tok*) * parameter_list (*tok*))
  | `Array_type_decl of (
        type_declarator (*tok*)
      * Token.t (* "[" *)
      * type_qualifier (*tok*) list (* zero or more *)
      * anon_choice_exp_508611b (*tok*) option
      * Token.t (* "]" *)
    )
  | `Paren_type_decl of (
        Token.t (* "(" *) * type_declarator (*tok*) * Token.t (* ")" *)
    )
  | `Id of identifier (*tok*)
]

and type_definition = (
    Token.t (* "typedef" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * type_specifier (*tok*)
  * type_declarator (*tok*)
  * (Token.t (* "," *) * type_declarator (*tok*)) list (* zero or more *)
  * Token.t (* ";" *)
)

and type_descriptor = (
    type_qualifier (*tok*) list (* zero or more *)
  * type_specifier (*tok*)
  * type_qualifier (*tok*) list (* zero or more *)
  * abstract_declarator (*tok*) option
)

and type_specifier = [
    `Struct_spec of (
        Token.t (* "struct" *)
      * ms_declspec_modifier (*tok*) option
      * anon_choice_class_name_d6703e6 (*tok*)
    )
  | `Union_spec of (
        Token.t (* "union" *)
      * ms_declspec_modifier (*tok*) option
      * anon_choice_class_name_d6703e6 (*tok*)
    )
  | `Enum_spec of (
        Token.t (* "enum" *)
      * [
            `Class of Token.t (* "class" *)
          | `Struct of Token.t (* "struct" *)
        ]
          option
      * [
            `Class_name_opt_enum_base_clause_opt_enum_list of (
                class_name (*tok*)
              * enum_base_clause (*tok*) option
              * enumerator_list (*tok*) option
            )
          | `Enum_list of enumerator_list (*tok*)
        ]
    )
  | `Class_spec of (
        Token.t (* "class" *)
      * ms_declspec_modifier (*tok*) option
      * anon_choice_class_name_d6703e6 (*tok*)
    )
  | `Sized_type_spec of sized_type_specifier (*tok*)
  | `Prim_type of primitive_type (*tok*)
  | `Temp_type of template_type (*tok*)
  | `Auto of Token.t (* "auto" *)
  | `Depe_type of (Token.t (* "typename" *) * type_specifier (*tok*))
  | `Decl of (
        Token.t (* "decltype" *) * Token.t (* "(" *) * expression (*tok*)
      * Token.t (* ")" *)
    )
  | `Choice_scoped_type_id of [
        `Scoped_type_id of scoped_type_identifier (*tok*)
      | `Id of identifier (*tok*)
    ]
]

and unary_expression = (
    anon_choice_BANG_67174d6 (*tok*) * expression (*tok*)
)

and update_expression = [
    `Choice_DASHDASH_exp of (
        anon_choice_DASHDASH_d11def2 (*tok*) * expression (*tok*)
    )
  | `Exp_choice_DASHDASH of (
        expression (*tok*) * anon_choice_DASHDASH_d11def2 (*tok*)
    )
]

and using_declaration = (
    Token.t (* "using" *)
  * Token.t (* "namespace" *) option
  * anon_choice_stmt_id_f1f5a37 (*tok*)
  * Token.t (* ";" *)
)

and variadic_parameter_declaration = (
    declaration_specifiers (*tok*)
  * [
        `Vari_decl of variadic_declarator (*tok*)
      | `Vari_ref_decl of variadic_reference_declarator (*tok*)
    ]
)
[@@deriving sexp_of]

type default_method_clause (* inlined *) = (
    Token.t (* "=" *) * Token.t (* "default" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type delete_method_clause (* inlined *) = (
    Token.t (* "=" *) * Token.t (* "delete" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    Token.t (* "continue" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type null (* inlined *) = Token.t (* "NULL" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type ms_unsigned_ptr_modifier (* inlined *) = Token.t (* "__uptr" *)
[@@deriving sexp_of]

type auto (* inlined *) = Token.t (* "auto" *)
[@@deriving sexp_of]

type this (* inlined *) = Token.t (* "this" *)
[@@deriving sexp_of]

type ms_signed_ptr_modifier (* inlined *) = Token.t (* "__sptr" *)
[@@deriving sexp_of]

type nullptr (* inlined *) = Token.t (* "nullptr" *)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    Token.t (* "break" *) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type ms_restrict_modifier (* inlined *) = Token.t (* "__restrict" *)
[@@deriving sexp_of]

type field_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type type_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type statement_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type namespace_identifier (* inlined *) = identifier (*tok*)
[@@deriving sexp_of]

type access_specifier (* inlined *) = (
    anon_choice_public_c9638d9 (*tok*) * Token.t (* ":" *)
)
[@@deriving sexp_of]

type goto_statement (* inlined *) = (
    Token.t (* "goto" *) * identifier (*tok*) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type structured_binding_declarator (* inlined *) = (
    Token.t (* "[" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type preproc_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * preproc_expression (*tok*) * Token.t (* ")" *)
)
[@@deriving sexp_of]

type preproc_unary_expression (* inlined *) = (
    anon_choice_BANG_67174d6 (*tok*) * preproc_expression (*tok*)
)
[@@deriving sexp_of]

type abstract_reference_declarator (* inlined *) = (
    anon_choice_AMP_c92c117 (*tok*)
  * abstract_declarator (*tok*) option
)
[@@deriving sexp_of]

type anon_opt_class_name_opt_virt_spec_opt_base_class_clause_field_decl_list_89302cc (* inlined *) = (
    class_name (*tok*) option
  * virtual_specifier (*tok*) option
  * base_class_clause (*tok*) option
  * field_declaration_list (*tok*)
)
[@@deriving sexp_of]

type array_type_declarator (* inlined *) = (
    type_declarator (*tok*)
  * Token.t (* "[" *)
  * type_qualifier (*tok*) list (* zero or more *)
  * anon_choice_exp_508611b (*tok*) option
  * Token.t (* "]" *)
)
[@@deriving sexp_of]

type class_specifier (* inlined *) = (
    Token.t (* "class" *)
  * ms_declspec_modifier (*tok*) option
  * anon_choice_class_name_d6703e6 (*tok*)
)
[@@deriving sexp_of]

type comma_expression (* inlined *) = (
    expression (*tok*) * Token.t (* "," *) * anon_choice_exp_55b4dba (*tok*)
)
[@@deriving sexp_of]

type decltype (* inlined *) = (
    Token.t (* "decltype" *) * Token.t (* "(" *) * expression (*tok*)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type delete_expression (* inlined *) = (
    Token.t (* "::" *) option
  * Token.t (* "delete" *)
  * (Token.t (* "[" *) * Token.t (* "]" *)) option
  * expression (*tok*)
)
[@@deriving sexp_of]

type dependent_type (* inlined *) = (
    Token.t (* "typename" *) * type_specifier (*tok*)
)
[@@deriving sexp_of]

type do_statement (* inlined *) = (
    Token.t (* "do" *) * statement (*tok*) * Token.t (* "while" *)
  * parenthesized_expression (*tok*) * Token.t (* ";" *)
)
[@@deriving sexp_of]

type enum_specifier (* inlined *) = (
    Token.t (* "enum" *)
  * [ `Class of Token.t (* "class" *) | `Struct of Token.t (* "struct" *) ]
      option
  * [
        `Class_name_opt_enum_base_clause_opt_enum_list of (
            class_name (*tok*)
          * enum_base_clause (*tok*) option
          * enumerator_list (*tok*) option
        )
      | `Enum_list of enumerator_list (*tok*)
    ]
)
[@@deriving sexp_of]

type for_range_loop (* inlined *) = (
    Token.t (* "for" *) * Token.t (* "(" *) * declaration_specifiers (*tok*)
  * declarator (*tok*) * Token.t (* ":" *) * anon_choice_exp_3078596 (*tok*)
  * Token.t (* ")" *) * statement (*tok*)
)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    Token.t (* "for" *)
  * Token.t (* "(" *)
  * [
        `Decl of declaration (*tok*)
      | `Opt_choice_exp_SEMI of expression_statement (*tok*)
    ]
  * expression (*tok*) option
  * Token.t (* ";" *)
  * anon_choice_exp_55b4dba (*tok*) option
  * Token.t (* ")" *)
  * statement (*tok*)
)
[@@deriving sexp_of]

type friend_declaration (* inlined *) = (
    Token.t (* "friend" *)
  * [
        `Decl of declaration (*tok*)
      | `Func_defi of function_definition (*tok*)
      | `Opt_choice_class_class_name_SEMI of (
            [
                `Class of Token.t (* "class" *)
              | `Struct of Token.t (* "struct" *)
              | `Union of Token.t (* "union" *)
            ]
              option
          * class_name (*tok*)
          * Token.t (* ";" *)
        )
    ]
)
[@@deriving sexp_of]

type function_type_declarator (* inlined *) = (
    type_declarator (*tok*) * parameter_list (*tok*)
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    Token.t (* "if" *)
  * Token.t (* "constexpr" *) option
  * condition_clause (*tok*)
  * statement (*tok*)
  * (Token.t (* "else" *) * statement (*tok*)) option
)
[@@deriving sexp_of]

type initializer_pair (* inlined *) = (
    [
        `Subs_desi of subscript_designator (*tok*)
      | `Field_desi of field_designator (*tok*)
    ]
      list (* one or more *)
  * Token.t (* "=" *)
  * anon_choice_exp_3078596 (*tok*)
)
[@@deriving sexp_of]

type inline_method_definition (* inlined *) = (
    attribute (*tok*) list (* zero or more *)
  * virtual_function_specifier (*tok*) option
  * declaration_specifiers (*tok*)
  * field_declarator (*tok*)
  * anon_choice_comp_stmt_be91723 (*tok*)
)
[@@deriving sexp_of]

type labeled_statement (* inlined *) = (
    identifier (*tok*) * Token.t (* ":" *) * statement (*tok*)
)
[@@deriving sexp_of]

type lambda_expression (* inlined *) = (
    lambda_capture_specifier (*tok*)
  * abstract_function_declarator (*tok*) option
  * compound_statement (*tok*)
)
[@@deriving sexp_of]

type namespace_definition (* inlined *) = (
    Token.t (* "namespace" *)
  * identifier (*tok*) option
  * declaration_list (*tok*)
)
[@@deriving sexp_of]

type new_expression (* inlined *) = (
    Token.t (* "::" *) option
  * Token.t (* "new" *)
  * argument_list (*tok*) option
  * type_specifier (*tok*)
  * new_declarator (*tok*) option
  * anon_choice_arg_list_e4b6f8f (*tok*) option
)
[@@deriving sexp_of]

type parameter_pack_expansion (* inlined *) = (
    expression (*tok*) * Token.t (* "..." *)
)
[@@deriving sexp_of]

type parenthesized_type_declarator (* inlined *) = (
    Token.t (* "(" *) * type_declarator (*tok*) * Token.t (* ")" *)
)
[@@deriving sexp_of]

type pointer_type_declarator (* inlined *) = (
    ms_based_modifier (*tok*) option
  * Token.t (* "*" *)
  * ms_pointer_modifier (*tok*) list (* zero or more *)
  * type_qualifier (*tok*) list (* zero or more *)
  * type_declarator (*tok*)
)
[@@deriving sexp_of]

type preproc_elif (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression (*tok*)
  * Token.t (* "\n" *)
  * translation_unit (*tok*)
  * anon_choice_prep_else_8b52b0f (*tok*) option
)
[@@deriving sexp_of]

type preproc_elif_in_field_declaration_list (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression (*tok*)
  * Token.t (* "\n" *)
  * field_declaration_list_item (*tok*) list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e (*tok*) option
)
[@@deriving sexp_of]

type preproc_else (* inlined *) = (pat_56631e5 * translation_unit (*tok*))
[@@deriving sexp_of]

type preproc_else_in_field_declaration_list (* inlined *) = (
    pat_56631e5
  * field_declaration_list_item (*tok*) list (* zero or more *)
)
[@@deriving sexp_of]

type reference_declarator (* inlined *) = (
    anon_choice_AMP_c92c117 (*tok*) * declarator (*tok*)
)
[@@deriving sexp_of]

type reference_field_declarator (* inlined *) = (
    anon_choice_AMP_c92c117 (*tok*) * field_declarator (*tok*)
)
[@@deriving sexp_of]

type scoped_field_identifier (* inlined *) = (
    anon_choice_stmt_id_ec78ce4 (*tok*) option
  * Token.t (* "::" *)
  * anon_choice_stmt_id_efddc5b (*tok*)
)
[@@deriving sexp_of]

type struct_specifier (* inlined *) = (
    Token.t (* "struct" *)
  * ms_declspec_modifier (*tok*) option
  * anon_choice_class_name_d6703e6 (*tok*)
)
[@@deriving sexp_of]

type switch_statement (* inlined *) = (
    Token.t (* "switch" *) * condition_clause (*tok*)
  * compound_statement (*tok*)
)
[@@deriving sexp_of]

type template_instantiation (* inlined *) = (
    Token.t (* "template" *)
  * declaration_specifiers (*tok*) option
  * declarator (*tok*)
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type template_template_parameter_declaration (* inlined *) = (
    Token.t (* "template" *)
  * template_parameter_list (*tok*)
  * [
        `Type_param_decl of type_parameter_declaration (*tok*)
      | `Vari_type_param_decl of variadic_type_parameter_declaration (*tok*)
      | `Opt_type_param_decl of optional_type_parameter_declaration (*tok*)
    ]
)
[@@deriving sexp_of]

type throw_statement (* inlined *) = (
    Token.t (* "throw" *)
  * expression (*tok*) option
  * Token.t (* ";" *)
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    Token.t (* "try" *)
  * compound_statement (*tok*)
  * catch_clause (*tok*) list (* one or more *)
)
[@@deriving sexp_of]

type type_parameter_pack_expansion (* inlined *) = (
    type_descriptor (*tok*) * Token.t (* "..." *)
)
[@@deriving sexp_of]

type union_specifier (* inlined *) = (
    Token.t (* "union" *)
  * ms_declspec_modifier (*tok*) option
  * anon_choice_class_name_d6703e6 (*tok*)
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    Token.t (* "while" *) * condition_clause (*tok*) * statement (*tok*)
)
[@@deriving sexp_of]

type macro_type_specifier (* inlined *) = (
    identifier (*tok*) * Token.t (* "(" *) * type_descriptor (*tok*)
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_translation_unit root
  |> Print_sexp.to_stdout
