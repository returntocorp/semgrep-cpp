(* Generated by ocaml-tree-sitter. *)
(*
   cpp grammar

   entrypoint: translation_unit
*)

open! Sexplib.Conv
open Tree_sitter_run

type true_ = Token.t

type anon_choice_EQ_6389fc4 = [
    `EQ of Token.t (* "=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `And_eq of Token.t (* "and_eq" *)
  | `Or_eq of Token.t (* "or_eq" *)
  | `Xor_eq of Token.t (* "xor_eq" *)
]

type anon_choice_type_a2fe5d4 = [
    `Type of Token.t (* "typename" *)
  | `Class of Token.t (* "class" *)
]

type primitive_type = Token.t

type fold_operator = [
    `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
  | `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
  | `HAT of Token.t (* "^" *)
  | `AMP of Token.t (* "&" *)
  | `BAR of Token.t (* "|" *)
  | `EQ of Token.t (* "=" *)
  | `LT of Token.t (* "<" *)
  | `GT of Token.t (* ">" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `EQEQ of Token.t (* "==" *)
  | `BANGEQ of Token.t (* "!=" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GTEQ of Token.t (* ">=" *)
  | `AMPAMP of Token.t (* "&&" *)
  | `BARBAR of Token.t (* "||" *)
  | `COMMA of Token.t (* "," *)
  | `DOTSTAR of Token.t (* ".*" *)
  | `DASHGTSTAR of Token.t (* "->*" *)
  | `Or of Token.t (* "or" *)
  | `And of Token.t (* "and" *)
  | `Bitor of Token.t (* "bitor" *)
  | `Xor of Token.t (* "xor" *)
  | `Bitand of Token.t (* "bitand" *)
  | `Not_eq of Token.t (* "not_eq" *)
]

type pat_bfeb4bb = Token.t (* pattern #[ 	]*elif *)

type preproc_directive = Token.t (* pattern #[ \t]*[a-zA-Z0-9]\w* *)

type access_specifier = [
    `Public of Token.t (* "public" *)
  | `Priv of Token.t (* "private" *)
  | `Prot of Token.t (* "protected" *)
]

type default_method_clause = (
    Token.t (* "=" *) * Token.t (* "default" *) * Token.t (* ";" *)
)

type pat_c3ea183 = Token.t (* pattern #[ 	]*define *)

type anon_choice_DASHDASH_d11def2 = [
    `DASHDASH of Token.t (* "--" *)
  | `PLUSPLUS of Token.t (* "++" *)
]

type delete_method_clause = (
    Token.t (* "=" *) * Token.t (* "delete" *) * Token.t (* ";" *)
)

type continue_statement = (Token.t (* "continue" *) * Token.t (* ";" *))

type storage_class_specifier = [
    `Extern of Token.t (* "extern" *)
  | `Static of Token.t (* "static" *)
  | `Regi of Token.t (* "register" *)
  | `Inline of Token.t (* "inline" *)
  | `X___inline of Token.t (* "__inline" *)
  | `X___inline__ of Token.t (* "__inline__" *)
  | `X___forc of Token.t (* "__forceinline" *)
  | `Thread_local of Token.t (* "thread_local" *)
  | `X___thread of Token.t (* "__thread" *)
]

type gnu_asm_qualifier = [
    `Vola of Token.t (* "volatile" *)
  | `Inline of Token.t (* "inline" *)
  | `Goto of Token.t (* "goto" *)
]

type null = [
    `NULL of Token.t (* "NULL" *)
  | `Null of Token.t (* "nullptr" *)
]

type pat_a6d4183 = Token.t (* pattern #[ 	]*elifndef *)

type escape_sequence = Token.t

type anon_choice_signed_a0bfc19 = [
    `Signed of Token.t (* "signed" *)
  | `Unsi of Token.t (* "unsigned" *)
  | `Long of Token.t (* "long" *)
  | `Short of Token.t (* "short" *)
]

type pat_0307ca2 = Token.t (* pattern #[ 	]*elifdef *)

type ms_unaligned_ptr_modifier = [
    `X__unal of Token.t (* "_unaligned" *)
  | `X___unal of Token.t (* "__unaligned" *)
]

type type_qualifier = [
    `Choice_const of [
        `Const of Token.t (* "const" *)
      | `Cons of Token.t (* "constexpr" *)
      | `Vola of Token.t (* "volatile" *)
      | `Rest of Token.t (* "restrict" *)
      | `X___rest__ of Token.t (* "__restrict__" *)
      | `X___exte__ of Token.t (* "__extension__" *)
      | `X__Atomic of Token.t (* "_Atomic" *)
      | `X__Nore of Token.t (* "_Noreturn" *)
      | `Nore of Token.t (* "noreturn" *)
    ]
  | `Muta of Token.t (* "mutable" *)
  | `Cons_36fe86c of Token.t (* "constinit" *)
  | `Cons_a25342f of Token.t (* "consteval" *)
]

type break_statement = (Token.t (* "break" *) * Token.t (* ";" *))

type semgrep_metavar = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type imm_tok_pat_36637e2 = Token.t (* pattern "[^\\n']" *)

type pat_9d92f6a = Token.t (* pattern #[ 	]*ifndef *)

type false_ = Token.t

type identifier =
  Token.t (* pattern \$?(\p{XID_Start}|_|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})(\p{XID_Continue}|\\u[0-9A-Fa-f]{4}|\\U[0-9A-Fa-f]{8})* *)

type seh_leave_statement = (Token.t (* "__leave" *) * Token.t (* ";" *))

type virtual_ = [ `Virt of Token.t (* "virtual" *) ]

type number_literal = Token.t

type raw_string_delimiter = Token.t

type pat_c46d1b2 = Token.t (* pattern #[ 	]*endif *)

type pat_3df6e71 = Token.t (* pattern #[ 	]*if *)

type preproc_arg = Token.t

type literal_suffix = Token.t (* pattern [a-zA-Z_]\w* *)

type semgrep_named_ellipsis = Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type system_lib_string = Token.t

type pat_ca8830e = Token.t (* pattern #[ 	]*include *)

type tok_prec_p1_gt = Token.t

type virtual_specifier = [
    `Final of Token.t (* "final" *)
  | `Over of Token.t (* "override" *)
]

type pat_25b90ba = Token.t (* pattern #[ 	]*ifdef *)

type imm_tok_pat_509ec78 = Token.t (* pattern \r?\n *)

type imm_tok_prec_p1_pat_c7f65b4 = Token.t (* pattern "[^\\\\\"\\n]+" *)

type ms_call_modifier = [
    `X___cdecl of Token.t (* "__cdecl" *)
  | `X___clrc of Token.t (* "__clrcall" *)
  | `X___stdc of Token.t (* "__stdcall" *)
  | `X___fast of Token.t (* "__fastcall" *)
  | `X___this of Token.t (* "__thiscall" *)
  | `X___vect of Token.t (* "__vectorcall" *)
]

type imm_tok_lpar = Token.t (* "(" *)

type pat_56631e5 = Token.t (* pattern #[ 	]*else *)

type raw_string_content = Token.t

type lambda_default_capture = [
    `EQ of Token.t (* "=" *)
  | `AMP of Token.t (* "&" *)
]

type ref_qualifier = [
    `AMP of Token.t (* "&" *)
  | `AMPAMP of Token.t (* "&&" *)
]

type anon_choice_BANG_67174d6 = [
    `BANG of Token.t (* "!" *)
  | `TILDE of Token.t (* "~" *)
  | `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
]

type decltype_auto = (
    Token.t (* "decltype" *) * Token.t (* "(" *) * Token.t (* "auto" *)
  * Token.t (* ")" *)
)

type binary_fold_operator = (
    fold_operator * Token.t (* "..." *) * fold_operator
)

type anon_choice_pat_0307ca2_dbf6a9d = [
    `Pat_0307ca2 of pat_0307ca2
  | `Pat_a6d4183 of pat_a6d4183
]

type ms_pointer_modifier = [
    `Ms_unal_ptr_modi of ms_unaligned_ptr_modifier
  | `Ms_rest_modi of Token.t (* "__restrict" *)
  | `Ms_unsi_ptr_modi of Token.t (* "__uptr" *)
  | `Ms_signed_ptr_modi of Token.t (* "__sptr" *)
]

type char_literal = (
    [
        `LSQUOT of Token.t (* "L'" *)
      | `USQUOT_d861d39 of Token.t (* "u'" *)
      | `USQUOT_2701bdc of Token.t (* "U'" *)
      | `U8SQUOT of Token.t (* "u8'" *)
      | `SQUOT of Token.t (* "'" *)
    ]
  * [
        `Esc_seq of escape_sequence (*tok*)
      | `Imm_tok_pat_36637e2 of imm_tok_pat_36637e2
    ]
      list (* one or more *)
  * Token.t (* "'" *)
)

type anon_choice_access_spec_23a010c = [
    `Access_spec of access_specifier
  | `Access_spec_virt of (access_specifier * virtual_)
  | `Virt_access_spec of (virtual_ * access_specifier)
]

type anon_choice_pat_25b90ba_4a37f8c = [
    `Pat_25b90ba of pat_25b90ba
  | `Pat_9d92f6a of pat_9d92f6a
]

type preproc_call = (
    preproc_directive (*tok*)
  * preproc_arg (*tok*) option
  * imm_tok_pat_509ec78
)

type string_literal = (
    [
        `LDQUOT of Token.t (* "L\"" *)
      | `UDQUOT_c163aae of Token.t (* "u\"" *)
      | `UDQUOT_df3447d of Token.t (* "U\"" *)
      | `U8DQUOT of Token.t (* "u8\"" *)
      | `DQUOT of Token.t (* "\"" *)
    ]
  * [
        `Imm_tok_prec_p1_pat_c7f65b4 of imm_tok_prec_p1_pat_c7f65b4
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)

type raw_string_literal = (
    [
        `RDQUOT of Token.t (* "R\"" *)
      | `LRDQUOT of Token.t (* "LR\"" *)
      | `URDQ of Token.t (* "uR\"" *)
      | `URDQUOT of Token.t (* "UR\"" *)
      | `U8RDQUOT of Token.t (* "u8R\"" *)
    ]
  * [
        `Raw_str_deli_LPAR_raw_str_content_RPAR_raw_str_deli of (
            raw_string_delimiter (*tok*) * Token.t (* "(" *)
          * raw_string_content (*tok*) * Token.t (* ")" *)
          * raw_string_delimiter (*tok*)
        )
      | `LPAR_raw_str_content_RPAR of (
            Token.t (* "(" *) * raw_string_content (*tok*)
          * Token.t (* ")" *)
        )
    ]
  * Token.t (* "\"" *)
)

type destructor_name = (Token.t (* "~" *) * identifier (*tok*))

type field_identifier = [
    `Id of identifier (*tok*)
  | `Semg_ellips of Token.t (* "..." *)
]

type operator_name = (
    Token.t (* "operator" *)
  * [
        `Co_await of Token.t (* "co_await" *)
      | `PLUS of Token.t (* "+" *)
      | `DASH of Token.t (* "-" *)
      | `STAR of Token.t (* "*" *)
      | `SLASH of Token.t (* "/" *)
      | `PERC of Token.t (* "%" *)
      | `HAT of Token.t (* "^" *)
      | `AMP of Token.t (* "&" *)
      | `BAR of Token.t (* "|" *)
      | `TILDE of Token.t (* "~" *)
      | `BANG of Token.t (* "!" *)
      | `EQ of Token.t (* "=" *)
      | `LT of Token.t (* "<" *)
      | `GT of Token.t (* ">" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `LTLT of Token.t (* "<<" *)
      | `GTGT of Token.t (* ">>" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `EQEQ of Token.t (* "==" *)
      | `BANGEQ of Token.t (* "!=" *)
      | `LTEQ of Token.t (* "<=" *)
      | `GTEQ of Token.t (* ">=" *)
      | `LTEQGT of Token.t (* "<=>" *)
      | `AMPAMP of Token.t (* "&&" *)
      | `BARBAR of Token.t (* "||" *)
      | `PLUSPLUS of Token.t (* "++" *)
      | `DASHDASH of Token.t (* "--" *)
      | `COMMA of Token.t (* "," *)
      | `DASHGTSTAR of Token.t (* "->*" *)
      | `DASHGT of Token.t (* "->" *)
      | `LPARRPAR of Token.t (* "()" *)
      | `LBRACKRBRACK of Token.t (* "[]" *)
      | `Xor of Token.t (* "xor" *)
      | `Bitand of Token.t (* "bitand" *)
      | `Bitor of Token.t (* "bitor" *)
      | `Compl of Token.t (* "compl" *)
      | `Not of Token.t (* "not" *)
      | `Xor_eq of Token.t (* "xor_eq" *)
      | `And_eq of Token.t (* "and_eq" *)
      | `Or_eq of Token.t (* "or_eq" *)
      | `Not_eq of Token.t (* "not_eq" *)
      | `And of Token.t (* "and" *)
      | `Or of Token.t (* "or" *)
      | `Choice_new_opt_LBRACKRBRACK of (
            [
                `New of Token.t (* "new" *)
              | `Delete of Token.t (* "delete" *)
            ]
          * Token.t (* "[]" *) option
        )
      | `DQUOTDQUOT_id of (Token.t (* "\"\"" *) * identifier (*tok*))
    ]
)

type type_parameter_declaration = (
    anon_choice_type_a2fe5d4
  * identifier (*tok*) option
)

type anon_choice_name_id_d3c4b5f = [
    `Id of identifier (*tok*)
  | `DOTDOTDOT of Token.t (* "..." *)
]

type preproc_defined = [
    `Defi_LPAR_id_RPAR of (
        Token.t (* "defined" *) * Token.t (* "(" *) * identifier (*tok*)
      * Token.t (* ")" *)
    )
  | `Defi_id of (Token.t (* "defined" *) * identifier (*tok*))
]

type variadic_declarator = (Token.t (* "..." *) * identifier (*tok*) option)

type preproc_def = (
    pat_c3ea183
  * identifier (*tok*)
  * preproc_arg (*tok*) option
  * imm_tok_pat_509ec78
)

type namespace_specifier = (
    Token.t (* "inline" *) option
  * identifier (*tok*)
)

type anon_choice_name_id_1a79fc3 = [
    `Id of identifier (*tok*)
  | `Prim_type of primitive_type (*tok*)
]

type variadic_type_parameter_declaration = (
    anon_choice_type_a2fe5d4
  * Token.t (* "..." *)
  * identifier (*tok*) option
)

type ms_declspec_modifier = (
    Token.t (* "__declspec" *) * Token.t (* "(" *) * identifier (*tok*)
  * Token.t (* ")" *)
)

type gnu_asm_goto_list = (
    Token.t (* ":" *)
  * (
        identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
    )
      option
)

type goto_statement = (
    Token.t (* "goto" *) * identifier (*tok*) * Token.t (* ";" *)
)

type anon_choice_name_id_fe6e1ce = [
    `Id of identifier (*tok*)
  | `Vari_param of Token.t (* "..." *)
]

type gnu_asm_clobber_list = (
    Token.t (* ":" *)
  * (
        string_literal
      * (Token.t (* "," *) * string_literal) list (* zero or more *)
    )
      option
)

type gnu_asm_output_operand = (
    (Token.t (* "[" *) * identifier (*tok*) * Token.t (* "]" *)) option
  * string_literal
  * Token.t (* "(" *)
  * identifier (*tok*)
  * Token.t (* ")" *)
)

type anon_choice_name_id_dd8d494 = [
    `Id of identifier (*tok*)
  | `Str_lit of string_literal
  | `Raw_str_lit of raw_string_literal
]

type field_designator = (Token.t (* "." *) * field_identifier)

type preproc_params = (
    imm_tok_lpar (*tok*)
  * (
        anon_choice_name_id_d3c4b5f
      * (Token.t (* "," *) * anon_choice_name_id_d3c4b5f)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type preproc_argument_list = (
    Token.t (* "(" *)
  * (
        preproc_expression
      * (Token.t (* "," *) * preproc_expression) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and preproc_binary_expression = [
    `Prep_exp_PLUS_prep_exp of (
        preproc_expression * Token.t (* "+" *) * preproc_expression
    )
  | `Prep_exp_DASH_prep_exp of (
        preproc_expression * Token.t (* "-" *) * preproc_expression
    )
  | `Prep_exp_STAR_prep_exp of (
        preproc_expression * Token.t (* "*" *) * preproc_expression
    )
  | `Prep_exp_SLASH_prep_exp of (
        preproc_expression * Token.t (* "/" *) * preproc_expression
    )
  | `Prep_exp_PERC_prep_exp of (
        preproc_expression * Token.t (* "%" *) * preproc_expression
    )
  | `Prep_exp_BARBAR_prep_exp of (
        preproc_expression * Token.t (* "||" *) * preproc_expression
    )
  | `Prep_exp_AMPAMP_prep_exp of (
        preproc_expression * Token.t (* "&&" *) * preproc_expression
    )
  | `Prep_exp_BAR_prep_exp of (
        preproc_expression * Token.t (* "|" *) * preproc_expression
    )
  | `Prep_exp_HAT_prep_exp of (
        preproc_expression * Token.t (* "^" *) * preproc_expression
    )
  | `Prep_exp_AMP_prep_exp of (
        preproc_expression * Token.t (* "&" *) * preproc_expression
    )
  | `Prep_exp_EQEQ_prep_exp of (
        preproc_expression * Token.t (* "==" *) * preproc_expression
    )
  | `Prep_exp_BANGEQ_prep_exp of (
        preproc_expression * Token.t (* "!=" *) * preproc_expression
    )
  | `Prep_exp_GT_prep_exp of (
        preproc_expression * Token.t (* ">" *) * preproc_expression
    )
  | `Prep_exp_GTEQ_prep_exp of (
        preproc_expression * Token.t (* ">=" *) * preproc_expression
    )
  | `Prep_exp_LTEQ_prep_exp of (
        preproc_expression * Token.t (* "<=" *) * preproc_expression
    )
  | `Prep_exp_LT_prep_exp of (
        preproc_expression * Token.t (* "<" *) * preproc_expression
    )
  | `Prep_exp_LTLT_prep_exp of (
        preproc_expression * Token.t (* "<<" *) * preproc_expression
    )
  | `Prep_exp_GTGT_prep_exp of (
        preproc_expression * Token.t (* ">>" *) * preproc_expression
    )
]

and preproc_call_expression = (identifier (*tok*) * preproc_argument_list)

and preproc_expression = [
    `Id of identifier (*tok*)
  | `Prep_call_exp of preproc_call_expression
  | `Num_lit of number_literal (*tok*)
  | `Char_lit of char_literal
  | `Prep_defi of preproc_defined
  | `Prep_un_exp of (anon_choice_BANG_67174d6 * preproc_expression)
  | `Prep_bin_exp of preproc_binary_expression
  | `Prep_paren_exp of (
        Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
    )
]

type variadic_reference_declarator = (
    [ `AMPAMP of Token.t (* "&&" *) | `AMP of Token.t (* "&" *) ]
  * variadic_declarator
)

type nested_namespace_specifier = (
    namespace_specifier option
  * Token.t (* "::" *)
  * [
        `Nested_name_spec of nested_namespace_specifier
      | `Name_spec of namespace_specifier
    ]
)

type sized_type_specifier = [
    `Rep_choice_signed_opt_choice_id_rep1_choice_signed of (
        anon_choice_signed_a0bfc19 list (* zero or more *)
      * anon_choice_name_id_1a79fc3 option
      * anon_choice_signed_a0bfc19 list (* one or more *)
    )
  | `Rep1_choice_signed_opt_choice_id_rep_choice_signed of (
        anon_choice_signed_a0bfc19 list (* one or more *)
      * anon_choice_name_id_1a79fc3 option
      * anon_choice_signed_a0bfc19 list (* zero or more *)
    )
]

type old_style_parameter_list = (
    Token.t (* "(" *)
  * (
        anon_choice_name_id_fe6e1ce
      * (Token.t (* "," *) * anon_choice_name_id_fe6e1ce)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type gnu_asm_output_operand_list = (
    Token.t (* ":" *)
  * (
        gnu_asm_output_operand
      * (Token.t (* "," *) * gnu_asm_output_operand) list (* zero or more *)
    )
      option
)

type concatenated_string = (
    anon_choice_name_id_dd8d494
  * [ `Str_lit of string_literal | `Raw_str_lit of raw_string_literal ]
  * anon_choice_name_id_dd8d494 list (* zero or more *)
)

type preproc_function_def = (
    pat_c3ea183
  * identifier (*tok*)
  * preproc_params
  * preproc_arg (*tok*) option
  * imm_tok_pat_509ec78
)

type preproc_include = (
    pat_ca8830e
  * [
        `Str_lit of string_literal
      | `System_lib_str of system_lib_string (*tok*)
      | `Id of identifier (*tok*)
      | `Prep_call_exp of preproc_call_expression
    ]
  * imm_tok_pat_509ec78
)

type anon_choice_name_id_7bae85c = [
    `Id of identifier (*tok*)
  | `Nested_name_spec of nested_namespace_specifier
]

type user_defined_literal = (
    [
        `Num_lit of number_literal (*tok*)
      | `Char_lit of char_literal
      | `Str_lit of string_literal
      | `Raw_str_lit of raw_string_literal
      | `Conc_str of concatenated_string
    ]
  * literal_suffix (*tok*)
)

type namespace_alias_definition = (
    Token.t (* "namespace" *) * identifier (*tok*) * Token.t (* "=" *)
  * anon_choice_name_id_7bae85c * Token.t (* ";" *)
)

type abstract_array_declarator = (
    abstract_declarator option
  * Token.t (* "[" *)
  * type_qualifier list (* zero or more *)
  * anon_choice_exp_508611b option
  * Token.t (* "]" *)
)

and abstract_declarator = [
    `Choice_abst_poin_decl of [
        `Abst_poin_decl of abstract_pointer_declarator
      | `Abst_func_decl of abstract_function_declarator
      | `Abst_array_decl of abstract_array_declarator
      | `Abst_paren_decl of abstract_parenthesized_declarator
    ]
  | `Abst_ref_decl of abstract_reference_declarator
]

and abstract_function_declarator = (
    abstract_declarator option
  * function_declarator_seq
)

and abstract_parenthesized_declarator = (
    Token.t (* "(" *) * abstract_declarator * Token.t (* ")" *)
)

and abstract_pointer_declarator = (
    Token.t (* "*" *)
  * type_qualifier list (* zero or more *)
  * abstract_declarator option
)

and abstract_reference_declarator = (
    ref_qualifier
  * abstract_declarator option
)

and alias_declaration = (
    Token.t (* "using" *)
  * identifier (*tok*)
  * attribute_declaration list (* zero or more *)
  * Token.t (* "=" *)
  * type_descriptor
  * Token.t (* ";" *)
)

and alignas_specifier = (
    Token.t (* "alignas" *)
  * Token.t (* "(" *)
  * [ `Exp of expression | `Prim_type of primitive_type (*tok*) ]
  * Token.t (* ")" *)
)

and alignof_expression = (
    [
        `X___alig__ of Token.t (* "__alignof__" *)
      | `X___alig of Token.t (* "__alignof" *)
      | `X__alig of Token.t (* "_alignof" *)
      | `Alig of Token.t (* "alignof" *)
      | `X__Alig of Token.t (* "_Alignof" *)
    ]
  * Token.t (* "(" *)
  * type_descriptor
  * Token.t (* ")" *)
)

and anon_choice_arg_list_e4b6f8f = [
    `Arg_list of argument_list
  | `Init_list of initializer_list
]

and anon_choice_bitf_clause_6707c09 = [
    `Bitf_clause of bitfield_clause
  | `Init_list of initializer_list
  | `EQ_choice_exp of (Token.t (* "=" *) * anon_choice_exp_3078596)
]

and anon_choice_comp_stmt_e6a11e2 = [
    `Comp_stmt of compound_statement
  | `Try_stmt of try_statement
]

and anon_choice_decl_opt_gnu_asm_exp_2c80446 = [
    `Decl_opt_gnu_asm_exp of (declarator * gnu_asm_expression option)
  | `Init_decl of init_declarator
]

and anon_choice_exp_3078596 = [
    `Exp of expression
  | `Init_list of initializer_list
]

and anon_choice_exp_508611b = [
    `Exp of expression
  | `STAR of Token.t (* "*" *)
]

and anon_choice_exp_55b4dba = [
    `Exp of expression
  | `Comma_exp of comma_expression
]

and anon_choice_init_pair_1a6981e = [
    `Init_pair of initializer_pair
  | `Exp of expression
  | `Init_list of initializer_list
]

and anon_choice_op_cast_b108b62 = [
    `Op_cast of operator_cast
  | `Qual_op_cast_id of qualified_operator_cast_identifier
]

and anon_choice_opt___exte___exp_16c9151 = [
    `Opt___exte___exp of (Token.t (* "__extension__" *) option * expression)
  | `Init_list of initializer_list
  | `Comp_stmt of compound_statement
]

and anon_choice_param_decl_13b5913 = [
    `Param_decl of parameter_declaration
  | `Opt_param_decl of optional_parameter_declaration
  | `Type_param_decl of type_parameter_declaration
  | `Vari_param_decl of variadic_parameter_declaration
  | `Vari_type_param_decl of variadic_type_parameter_declaration
  | `Opt_type_param_decl of optional_type_parameter_declaration
  | `Temp_temp_param_decl of (
        Token.t (* "template" *)
      * template_parameter_list
      * [
            `Type_param_decl of type_parameter_declaration
          | `Vari_type_param_decl of variadic_type_parameter_declaration
          | `Opt_type_param_decl of optional_type_parameter_declaration
        ]
    )
]

and anon_choice_param_decl_1a61eef = [
    `Param_decl of parameter_declaration
  | `Opt_param_decl of optional_parameter_declaration
  | `Vari_param_decl of variadic_parameter_declaration
]

and anon_choice_param_decl_d9083af = [
    `Param_decl of parameter_declaration
  | `Opt_param_decl of optional_parameter_declaration
  | `Vari_param_decl of variadic_parameter_declaration
  | `DOTDOTDOT of Token.t (* "..." *)
]

and anon_choice_prep_else_8b52b0f = [
    `Prep_else of (pat_56631e5 * block_item list (* zero or more *))
  | `Prep_elif of (
        pat_bfeb4bb
      * preproc_expression
      * Token.t (* "\n" *)
      * block_item list (* zero or more *)
      * anon_choice_prep_else_8b52b0f option
    )
]

and anon_choice_prep_else_in_enum_list_8258275 = [
    `Prep_else_in_enum_list of (
        pat_56631e5
      * (enumerator * Token.t (* "," *)) list (* zero or more *)
    )
  | `Prep_elif_in_enum_list of (
        pat_bfeb4bb
      * preproc_expression
      * Token.t (* "\n" *)
      * (enumerator * Token.t (* "," *)) list (* zero or more *)
      * anon_choice_prep_else_in_enum_list_8258275 option
    )
]

and anon_choice_prep_else_in_enum_list_no_comma_04fd5a5 = [
    `Prep_else_in_enum_list_no_comma of (
        pat_56631e5
      * enumerator list (* zero or more *)
    )
  | `Prep_elif_in_enum_list_no_comma of (
        pat_bfeb4bb
      * preproc_expression
      * Token.t (* "\n" *)
      * enumerator list (* zero or more *)
      * anon_choice_prep_else_in_enum_list_no_comma_04fd5a5 option
    )
]

and anon_choice_prep_else_in_field_decl_list_97ea65e = [
    `Prep_else_in_field_decl_list of (
        pat_56631e5
      * field_declaration_list_item list (* zero or more *)
    )
  | `Prep_elif_in_field_decl_list of (
        pat_bfeb4bb
      * preproc_expression
      * Token.t (* "\n" *)
      * field_declaration_list_item list (* zero or more *)
      * anon_choice_prep_else_in_field_decl_list_97ea65e option
    )
]

and anon_choice_type_desc_4d9cafa = [
    `Type_desc of type_descriptor
  | `Type_param_pack_expa of (type_descriptor * Token.t (* "..." *))
  | `Exp of expression
]

and argument_list = (
    Token.t (* "(" *)
  * (
        anon_choice_opt___exte___exp_16c9151
      * (Token.t (* "," *) * anon_choice_opt___exte___exp_16c9151)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and array_declarator = (
    declarator
  * Token.t (* "[" *)
  * type_qualifier list (* zero or more *)
  * anon_choice_exp_508611b option
  * Token.t (* "]" *)
)

and array_field_declarator = (
    field_declarator
  * Token.t (* "[" *)
  * type_qualifier list (* zero or more *)
  * anon_choice_exp_508611b option
  * Token.t (* "]" *)
)

and assignment_expression = (
    assignment_left_expression * anon_choice_EQ_6389fc4
  * anon_choice_exp_3078596
)

and assignment_expression_lhs_expression = (
    expression * anon_choice_EQ_6389fc4 * anon_choice_exp_3078596
)

and assignment_left_expression = [
    `Choice_id of [
        `Id of identifier (*tok*)
      | `Call_exp of call_expression
      | `Field_exp of field_expression
      | `Poin_exp of pointer_expression
      | `Subs_exp of subscript_expression
      | `Paren_exp of parenthesized_expression
    ]
  | `Qual_id of qualified_identifier
  | `User_defi_lit of user_defined_literal
]

and attribute = (
    (identifier (*tok*) * Token.t (* "::" *)) option
  * identifier (*tok*)
  * argument_list option
)

and attribute_declaration = (
    Token.t (* "[[" *)
  * attribute
  * (Token.t (* "," *) * attribute) list (* zero or more *)
  * Token.t (* "]]" *)
)

and attribute_specifier = (
    Token.t (* "__attribute__" *) * Token.t (* "(" *) * argument_list
  * Token.t (* ")" *)
)

and attributed_declarator = (
    declarator
  * attribute_declaration list (* one or more *)
)

and attributed_field_declarator = (
    field_declarator
  * attribute_declaration list (* one or more *)
)

and attributed_statement = (
    attribute_declaration list (* one or more *)
  * statement
)

and base_class_clause = (
    Token.t (* ":" *)
  * attribute_declaration list (* zero or more *)
  * anon_choice_access_spec_23a010c option
  * class_name
  * Token.t (* "..." *) option
  * (
        Token.t (* "," *)
      * attribute_declaration list (* zero or more *)
      * anon_choice_access_spec_23a010c option
      * class_name
      * Token.t (* "..." *) option
    )
      list (* zero or more *)
)

and binary_expression = [
    `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_LTEQGT_exp of (expression * Token.t (* "<=>" *) * expression)
  | `Exp_or_exp of (expression * Token.t (* "or" *) * expression)
  | `Exp_and_exp of (expression * Token.t (* "and" *) * expression)
  | `Exp_bitor_exp of (expression * Token.t (* "bitor" *) * expression)
  | `Exp_xor_exp of (expression * Token.t (* "xor" *) * expression)
  | `Exp_bitand_exp of (expression * Token.t (* "bitand" *) * expression)
  | `Exp_not_eq_exp of (expression * Token.t (* "not_eq" *) * expression)
]

and binary_fold = (expression * binary_fold_operator * expression)

and bitfield_clause = (Token.t (* ":" *) * expression)

and block_item = [
    `Choice_func_defi of [
        `Func_defi of function_definition
      | `Link_spec of linkage_specification
      | `Decl of declaration
      | `Choice_case_stmt of statement
      | `Attr_stmt of attributed_statement
      | `Type_defi of type_definition
      | `Empty_decl of empty_declaration
      | `Prep_if of preproc_if
      | `Prep_ifdef of preproc_ifdef
      | `Prep_incl of preproc_include
      | `Prep_def of preproc_def
      | `Prep_func_def of preproc_function_def
      | `Prep_call of preproc_call
      | `Name_defi of namespace_definition
      | `Conc_defi of concept_definition
      | `Name_alias_defi of namespace_alias_definition
      | `Using_decl of using_declaration
      | `Alias_decl of alias_declaration
      | `Static_assert_decl of static_assert_declaration
      | `Temp_decl of template_declaration
      | `Temp_inst of template_instantiation
      | `Cons_or_dest_defi of constructor_or_destructor_definition
      | `Op_cast_defi of operator_cast_definition
      | `Op_cast_decl of operator_cast_declaration
    ]
  | `Semg_ellips of Token.t (* "..." *)
]

and call_expression = [
    `Exp_arg_list of (expression * argument_list)
  | `Prim_type_arg_list of (primitive_type (*tok*) * argument_list)
]

and case_statement = (
    [
        `Case_exp of (Token.t (* "case" *) * expression)
      | `Defa of Token.t (* "default" *)
    ]
  * Token.t (* ":" *)
  * [
        `Choice_choice_attr_stmt of non_case_statement
      | `Decl of declaration
      | `Type_defi of type_definition
    ]
      list (* zero or more *)
)

and cast_expression = (
    Token.t (* "(" *) * type_descriptor * Token.t (* ")" *) * expression
)

and catch_clause = (
    Token.t (* "catch" *) * parameter_list * compound_statement
)

and class_declaration = (
    [
        `Attr_spec of attribute_specifier
      | `Alignas_spec of alignas_specifier
    ]
      list (* zero or more *)
  * ms_declspec_modifier option
  * attribute_declaration list (* zero or more *)
  * class_declaration_item
)

and class_declaration_item = (
    [
        `Class_name of class_name
      | `Opt_class_name_opt_virt_spec_opt_base_class_clause_field_decl_list of (
            class_name option
          * virtual_specifier option
          * base_class_clause option
          * field_declaration_list
        )
    ]
  * attribute_specifier option
)

and class_name = [
    `Id of identifier (*tok*)
  | `Temp_type of template_type
  | `Qual_type_id of qualified_type_identifier
]

and co_return_statement = (
    Token.t (* "co_return" *)
  * expression option
  * Token.t (* ";" *)
)

and co_yield_statement = (
    Token.t (* "co_yield" *) * expression * Token.t (* ";" *)
)

and comma_expression = (
    expression * Token.t (* "," *) * anon_choice_exp_55b4dba
)

and compound_literal_expression = [
    `LPAR_type_desc_RPAR_init_list of (
        Token.t (* "(" *) * type_descriptor * Token.t (* ")" *)
      * initializer_list
    )
  | `Choice_class_name_init_list of (
        [ `Class_name of class_name | `Prim_type of primitive_type (*tok*) ]
      * initializer_list
    )
]

and compound_statement = (
    Token.t (* "{" *)
  * block_item list (* zero or more *)
  * Token.t (* "}" *)
)

and concept_definition = (
    Token.t (* "concept" *) * identifier (*tok*) * Token.t (* "=" *)
  * expression * Token.t (* ";" *)
)

and condition_clause = (
    Token.t (* "(" *)
  * init_statement option
  * [
        `Exp of expression
      | `Comma_exp of comma_expression
      | `Cond_decl of condition_declaration
    ]
  * Token.t (* ")" *)
)

and condition_declaration = (
    declaration_specifiers
  * declarator
  * [
        `EQ_exp of (Token.t (* "=" *) * expression)
      | `Init_list of initializer_list
    ]
)

and conditional_expression = (
    expression
  * Token.t (* "?" *)
  * expression option
  * Token.t (* ":" *)
  * expression
)

and constructor_or_destructor_declaration = (
    constructor_specifiers list (* zero or more *)
  * function_declarator
  * Token.t (* ";" *)
)

and constructor_or_destructor_definition = (
    constructor_specifiers list (* zero or more *)
  * function_declarator
  * [
        `Opt_field_init_list_comp_stmt of (
            field_initializer_list option
          * compound_statement
        )
      | `Cons_try_stmt of constructor_try_statement
      | `Defa_meth_clause of default_method_clause
      | `Delete_meth_clause of delete_method_clause
    ]
)

and constructor_specifiers = [
    `Decl_modifs of declaration_modifiers
  | `Expl_func_spec of explicit_function_specifier
]

and constructor_try_statement = (
    Token.t (* "try" *)
  * field_initializer_list option
  * compound_statement
  * catch_clause list (* one or more *)
)

and declaration = (
    declaration_specifiers * declaration_declarator * Token.t (* ";" *)
)

and declaration_declarator = (
    anon_choice_decl_opt_gnu_asm_exp_2c80446
  * (Token.t (* "," *) * anon_choice_decl_opt_gnu_asm_exp_2c80446)
      list (* zero or more *)
)

and declaration_list = (
    Token.t (* "{" *)
  * block_item list (* zero or more *)
  * Token.t (* "}" *)
)

and declaration_modifiers = [
    `Choice_stor_class_spec of [
        `Stor_class_spec of storage_class_specifier
      | `Type_qual of type_qualifier
      | `Attr_spec of attribute_specifier
      | `Attr_decl of attribute_declaration
      | `Ms_decl_modi of ms_declspec_modifier
    ]
  | `Virt of virtual_
  | `Alignas_spec of alignas_specifier
]

and declaration_specifiers = (
    declaration_modifiers list (* zero or more *)
  * type_specifier
  * declaration_modifiers list (* zero or more *)
)

and declarator = [
    `Choice_attr_decl of [
        `Attr_decl of attributed_declarator
      | `Poin_decl of pointer_declarator
      | `Func_decl of function_declarator
      | `Array_decl of array_declarator
      | `Paren_decl of parenthesized_declarator
      | `Id of identifier (*tok*)
    ]
  | `Ref_decl of (ref_qualifier * declarator)
  | `Qual_id of qualified_identifier
  | `Temp_func of template_function
  | `Op_name of operator_name
  | `Dest_name of destructor_name
  | `Stru_bind_decl of (
        Token.t (* "[" *)
      * identifier (*tok*)
      * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
      * Token.t (* "]" *)
    )
]

and decltype = (
    Token.t (* "decltype" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *)
)

and dependent_field_identifier = (Token.t (* "template" *) * template_method)

and dependent_identifier = (Token.t (* "template" *) * template_function)

and dependent_type_identifier = (Token.t (* "template" *) * template_type)

and do_statement = (
    Token.t (* "do" *) * statement * Token.t (* "while" *)
  * parenthesized_expression * Token.t (* ";" *)
)

and else_clause = (Token.t (* "else" *) * statement)

and empty_declaration = (type_specifier * Token.t (* ";" *))

and enum_base_clause = (
    Token.t (* ":" *)
  * [
        `Qual_type_id of qualified_type_identifier
      | `Id of identifier (*tok*)
      | `Prim_type of primitive_type (*tok*)
      | `Sized_type_spec of sized_type_specifier
    ]
)

and enumerator = (
    identifier (*tok*)
  * (Token.t (* "=" *) * expression) option
)

and enumerator_list = (
    Token.t (* "{" *)
  * [
        `Enum_COMMA of (enumerator * Token.t (* "," *))
      | `Prep_if_in_enum_list of preproc_if_in_enumerator_list
      | `Prep_ifdef_in_enum_list of preproc_ifdef_in_enumerator_list
      | `Prep_call_COMMA of (preproc_call * Token.t (* "," *))
    ]
      list (* zero or more *)
  * [
        `Enum of enumerator
      | `Prep_if_in_enum_list_no_comma of
          preproc_if_in_enumerator_list_no_comma
      | `Prep_ifdef_in_enum_list_no_comma of
          preproc_ifdef_in_enumerator_list_no_comma
      | `Prep_call of preproc_call
    ]
      option
  * Token.t (* "}" *)
)

and explicit_function_specifier = [
    `Expl of Token.t (* "explicit" *)
  | `Expl_LPAR_exp_RPAR of (
        Token.t (* "explicit" *) * Token.t (* "(" *) * expression
      * Token.t (* ")" *)
    )
]

and expression = [
    `Choice_exp_not_bin of [
        `Exp_not_bin of expression_not_binary
      | `Bin_exp of binary_expression
    ]
  | `Semg_ellips of Token.t (* "..." *)
  | `Deep_ellips of (
        Token.t (* "<..." *) * expression * Token.t (* "...>" *)
    )
  | `Semg_named_ellips of semgrep_named_ellipsis (*tok*)
]

and expression_not_binary = [
    `Choice_cond_exp of [
        `Cond_exp of conditional_expression
      | `Assign_exp of assignment_expression
      | `Un_exp of unary_expression
      | `Update_exp of update_expression
      | `Cast_exp of cast_expression
      | `Poin_exp of pointer_expression
      | `Sizeof_exp of sizeof_expression
      | `Alig_exp of alignof_expression
      | `Offs_exp of offsetof_expression
      | `Gene_exp of generic_expression
      | `Subs_exp of subscript_expression
      | `Call_exp of call_expression
      | `Field_exp of field_expression
      | `Comp_lit_exp of compound_literal_expression
      | `Id of identifier (*tok*)
      | `Num_lit of number_literal (*tok*)
      | `Str_lit of string_literal
      | `True of true_ (*tok*)
      | `False of false_ (*tok*)
      | `Null of null
      | `Conc_str of concatenated_string
      | `Char_lit of char_literal
      | `Paren_exp of parenthesized_expression
      | `Gnu_asm_exp of gnu_asm_expression
    ]
  | `Co_await_exp of (Token.t (* "co_await" *) * expression)
  | `Requis_exp of requires_expression
  | `Requis_clause of requires_clause
  | `Temp_func of template_function
  | `Qual_id of qualified_identifier
  | `New_exp of (
        Token.t (* "::" *) option
      * Token.t (* "new" *)
      * argument_list option
      * type_specifier
      * new_declarator option
      * anon_choice_arg_list_e4b6f8f option
    )
  | `Delete_exp of (
        Token.t (* "::" *) option
      * Token.t (* "delete" *)
      * (Token.t (* "[" *) * Token.t (* "]" *)) option
      * expression
    )
  | `Lambda_exp of lambda_expression
  | `Param_pack_expa of (expression * Token.t (* "..." *))
  | `This of Token.t (* "this" *)
  | `Raw_str_lit of raw_string_literal
  | `User_defi_lit of user_defined_literal
  | `Fold_exp of fold_expression
]

and expression_statement = (
    anon_choice_exp_55b4dba option
  * Token.t (* ";" *)
)

and field_declaration = (
    declaration_specifiers
  * (
        field_declarator
      * anon_choice_bitf_clause_6707c09 option
      * (
            Token.t (* "," *)
          * field_declarator
          * anon_choice_bitf_clause_6707c09 option
        )
          list (* zero or more *)
    )
      option
  * attribute_specifier option
  * Token.t (* ";" *)
)

and field_declaration_list = (
    Token.t (* "{" *)
  * field_declaration_list_item list (* zero or more *)
  * Token.t (* "}" *)
)

and field_declaration_list_item = [
    `Choice_field_decl of [
        `Field_decl of field_declaration
      | `Prep_def of preproc_def
      | `Prep_func_def of preproc_function_def
      | `Prep_call of preproc_call
      | `Prep_if_in_field_decl_list of preproc_if_in_field_declaration_list
      | `Prep_ifdef_in_field_decl_list of
          preproc_ifdef_in_field_declaration_list
    ]
  | `Temp_decl of template_declaration
  | `Inline_meth_defi of (
        declaration_specifiers
      * field_declarator
      * [
            `Choice_comp_stmt of anon_choice_comp_stmt_e6a11e2
          | `Defa_meth_clause of default_method_clause
          | `Delete_meth_clause of delete_method_clause
        ]
    )
  | `Cons_or_dest_defi of constructor_or_destructor_definition
  | `Cons_or_dest_decl of constructor_or_destructor_declaration
  | `Op_cast_defi of operator_cast_definition
  | `Op_cast_decl of operator_cast_declaration
  | `Friend_decl of friend_declaration
  | `Access_spec_COLON of (access_specifier * Token.t (* ":" *))
  | `Alias_decl of alias_declaration
  | `Using_decl of using_declaration
  | `Type_defi of type_definition
  | `Static_assert_decl of static_assert_declaration
]

and field_declarator = [
    `Choice_attr_field_decl of [
        `Attr_field_decl of attributed_field_declarator
      | `Poin_field_decl of pointer_field_declarator
      | `Func_field_decl of function_field_declarator
      | `Array_field_decl of array_field_declarator
      | `Paren_field_decl of parenthesized_field_declarator
      | `Choice_id of field_identifier
    ]
  | `Ref_field_decl of (ref_qualifier * field_declarator)
  | `Temp_meth of template_method
  | `Op_name of operator_name
]

and field_expression = (
    expression
  * [
        `DOT of Token.t (* "." *)
      | `DOTSTAR of Token.t (* ".*" *)
      | `DASHGT of Token.t (* "->" *)
    ]
  * [
        `Choice_id of field_identifier
      | `Dest_name of destructor_name
      | `Temp_meth of template_method
      | `Depe_field_id of dependent_field_identifier
    ]
)

and field_initializer = (
    [
        `Choice_id of field_identifier
      | `Temp_meth of template_method
      | `Qual_field_id of qualified_field_identifier
    ]
  * [ `Init_list of initializer_list | `Arg_list of argument_list ]
  * Token.t (* "..." *) option
)

and field_initializer_list = (
    Token.t (* ":" *)
  * field_initializer
  * (Token.t (* "," *) * field_initializer) list (* zero or more *)
)

and fold_expression = (
    Token.t (* "(" *)
  * [
        `Un_right_fold of unary_right_fold
      | `Un_left_fold of unary_left_fold
      | `Bin_fold of binary_fold
    ]
  * Token.t (* ")" *)
)

and for_range_loop = (
    Token.t (* "for" *) * Token.t (* "(" *) * for_range_loop_body
  * Token.t (* ")" *) * statement
)

and for_range_loop_body = (
    init_statement option
  * declaration_specifiers
  * declarator
  * Token.t (* ":" *)
  * anon_choice_exp_3078596
)

and for_statement = (
    Token.t (* "for" *) * Token.t (* "(" *) * for_statement_body
  * Token.t (* ")" *) * statement
)

and for_statement_body = (
    [ `Decl of declaration | `Opt_choice_exp_SEMI of expression_statement ]
  * anon_choice_exp_55b4dba option
  * Token.t (* ";" *)
  * anon_choice_exp_55b4dba option
)

and friend_declaration = (
    Token.t (* "friend" *)
  * [
        `Decl of declaration
      | `Func_defi of function_definition
      | `Opt_choice_class_class_name_SEMI of (
            [
                `Class of Token.t (* "class" *)
              | `Struct of Token.t (* "struct" *)
              | `Union of Token.t (* "union" *)
            ]
              option
          * class_name
          * Token.t (* ";" *)
        )
    ]
)

and function_attributes_end = (
    gnu_asm_expression option
  * [
        `Rep1_attr_spec_rep_attr_decl of (
            attribute_specifier list (* one or more *)
          * attribute_declaration list (* zero or more *)
        )
      | `Rep_attr_spec_rep1_attr_decl of (
            attribute_specifier list (* zero or more *)
          * attribute_declaration list (* one or more *)
        )
    ]
)

and function_attributes_start = [
    `Rep1_attr_spec_rep_type_qual of (
        attribute_specifier list (* one or more *)
      * type_qualifier list (* zero or more *)
    )
  | `Rep_attr_spec_rep1_type_qual of (
        attribute_specifier list (* zero or more *)
      * type_qualifier list (* one or more *)
    )
]

and function_declarator = (declarator * function_declarator_seq)

and function_declarator_seq = (
    parameter_list
  * function_attributes_start option
  * ref_qualifier option
  * function_exception_specification option
  * function_attributes_end option
  * trailing_return_type option
  * function_postfix option
)

and function_definition = (
    ms_call_modifier option
  * declaration_specifiers
  * declarator
  * anon_choice_comp_stmt_e6a11e2
)

and function_exception_specification = [
    `Noex of (
        Token.t (* "noexcept" *)
      * (Token.t (* "(" *) * expression option * Token.t (* ")" *)) option
    )
  | `Throw_spec of (
        Token.t (* "throw" *)
      * Token.t (* "(" *)
      * (
            type_descriptor
          * (Token.t (* "," *) * type_descriptor) list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
]

and function_field_declarator = (field_declarator * function_declarator_seq)

and function_postfix = [
    `Rep1_virt_spec of virtual_specifier list (* one or more *)
  | `Requis_clause of requires_clause
]

and generic_expression = (
    Token.t (* "_Generic" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* "," *)
  * type_descriptor
  * Token.t (* ":" *)
  * expression
  * (Token.t (* "," *) * type_descriptor * Token.t (* ":" *) * expression)
      list (* zero or more *)
  * Token.t (* ")" *)
)

and gnu_asm_expression = (
    [ `Asm of Token.t (* "asm" *) | `X___asm__ of Token.t (* "__asm__" *) ]
  * gnu_asm_qualifier list (* zero or more *)
  * Token.t (* "(" *)
  * [ `Str_lit of string_literal | `Conc_str of concatenated_string ]
  * (
        gnu_asm_output_operand_list
      * (
            gnu_asm_input_operand_list
          * (gnu_asm_clobber_list * gnu_asm_goto_list option) option
        )
          option
    )
      option
  * Token.t (* ")" *)
)

and gnu_asm_input_operand = (
    (Token.t (* "[" *) * identifier (*tok*) * Token.t (* "]" *)) option
  * string_literal
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
)

and gnu_asm_input_operand_list = (
    Token.t (* ":" *)
  * (
        gnu_asm_input_operand
      * (Token.t (* "," *) * gnu_asm_input_operand) list (* zero or more *)
    )
      option
)

and if_statement = (
    Token.t (* "if" *)
  * Token.t (* "constexpr" *) option
  * condition_clause
  * statement
  * else_clause option
)

and init_declarator = [
    `Decl_EQ_choice_init_list of (
        declarator
      * Token.t (* "=" *)
      * [ `Init_list of initializer_list | `Exp of expression ]
    )
  | `Decl_choice_arg_list of (declarator * anon_choice_arg_list_e4b6f8f)
]

and init_statement = [
    `Alias_decl of alias_declaration
  | `Type_defi of type_definition
  | `Decl of declaration
  | `Exp_stmt of expression_statement
]

and initializer_list = (
    Token.t (* "{" *)
  * (
        anon_choice_init_pair_1a6981e
      * (Token.t (* "," *) * anon_choice_init_pair_1a6981e)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and initializer_pair = [
    `Rep1_choice_subs_desi_EQ_choice_exp of (
        [
            `Subs_desi of subscript_designator
          | `Field_desi of field_designator
          | `Subs_range_desi of subscript_range_designator
        ]
          list (* one or more *)
      * Token.t (* "=" *)
      * anon_choice_exp_3078596
    )
  | `Choice_id_COLON_choice_exp of (
        field_identifier * Token.t (* ":" *) * anon_choice_exp_3078596
    )
]

and labeled_statement = (identifier (*tok*) * Token.t (* ":" *) * statement)

and lambda_capture_specifier = (
    Token.t (* "[" *)
  * [
        `Lambda_defa_capt of lambda_default_capture
      | `Opt_exp_rep_COMMA_exp of
          (
              expression
            * (Token.t (* "," *) * expression) list (* zero or more *)
          )
            option
      | `Lambda_defa_capt_COMMA_exp_rep_COMMA_exp of (
            lambda_default_capture
          * Token.t (* "," *)
          * expression
          * (Token.t (* "," *) * expression) list (* zero or more *)
        )
    ]
  * Token.t (* "]" *)
)

and lambda_expression = (
    lambda_capture_specifier
  * (template_parameter_list * requires_clause option) option
  * abstract_function_declarator option
  * compound_statement
)

and linkage_specification = (
    Token.t (* "extern" *)
  * string_literal
  * [
        `Func_defi of function_definition
      | `Decl of declaration
      | `Decl_list of declaration_list
    ]
)

and ms_based_modifier = (Token.t (* "__based" *) * argument_list)

and namespace_definition = (
    Token.t (* "inline" *) option
  * Token.t (* "namespace" *)
  * anon_choice_name_id_7bae85c option
  * declaration_list
)

and new_declarator = [
  `Rectype of (
      Token.t (* "[" *)
    * expression
    * Token.t (* "]" *)
    * new_declarator option
  )
]

and non_case_statement = [
    `Choice_attr_stmt of [
        `Attr_stmt of attributed_statement
      | `Labe_stmt of labeled_statement
      | `Comp_stmt of compound_statement
      | `Exp_stmt of expression_statement
      | `If_stmt of if_statement
      | `Switch_stmt of switch_statement
      | `Do_stmt of do_statement
      | `While_stmt of while_statement
      | `For_stmt of for_statement
      | `Ret_stmt of return_statement
      | `Brk_stmt of break_statement
      | `Cont_stmt of continue_statement
      | `Goto_stmt of goto_statement
      | `Seh_try_stmt of seh_try_statement
      | `Seh_leave_stmt of seh_leave_statement
    ]
  | `Co_ret_stmt of co_return_statement
  | `Co_yield_stmt of co_yield_statement
  | `For_range_loop of for_range_loop
  | `Try_stmt of try_statement
  | `Throw_stmt of throw_statement
]

and offsetof_expression = (
    Token.t (* "offsetof" *) * Token.t (* "(" *) * type_descriptor
  * Token.t (* "," *) * field_identifier * Token.t (* ")" *)
)

and operator_cast = (
    Token.t (* "operator" *) * declaration_specifiers * abstract_declarator
)

and operator_cast_declaration = (
    constructor_specifiers list (* zero or more *)
  * anon_choice_op_cast_b108b62
  * (Token.t (* "=" *) * expression) option
  * Token.t (* ";" *)
)

and operator_cast_definition = (
    constructor_specifiers list (* zero or more *)
  * anon_choice_op_cast_b108b62
  * anon_choice_comp_stmt_e6a11e2
)

and optional_parameter_declaration = (
    declaration_specifiers
  * [ `Decl of declarator | `Abst_ref_decl of abstract_reference_declarator ]
      option
  * Token.t (* "=" *)
  * expression
)

and optional_type_parameter_declaration = (
    anon_choice_type_a2fe5d4
  * identifier (*tok*) option
  * Token.t (* "=" *)
  * type_specifier
)

and parameter_declaration = (
    declaration_specifiers
  * [ `Decl of declarator | `Abst_decl of abstract_declarator ] option
)

and parameter_list = (
    Token.t (* "(" *)
  * (
        anon_choice_param_decl_d9083af
      * (Token.t (* "," *) * anon_choice_param_decl_d9083af)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and parenthesized_declarator = (
    Token.t (* "(" *) * declarator * Token.t (* ")" *)
)

and parenthesized_expression = [
    `Choice_LPAR_choice_exp_RPAR of [
        `LPAR_choice_exp_RPAR of (
            Token.t (* "(" *) * anon_choice_exp_55b4dba * Token.t (* ")" *)
        )
      | `LPAR_assign_exp_lhs_exp_RPAR of (
            Token.t (* "(" *) * assignment_expression_lhs_expression
          * Token.t (* ")" *)
        )
    ]
  | `LPAR_semg_typed_meta_RPAR of (
        Token.t (* "(" *) * semgrep_typed_metavar * Token.t (* ")" *)
    )
]

and parenthesized_field_declarator = (
    Token.t (* "(" *) * field_declarator * Token.t (* ")" *)
)

and pointer_declarator = (
    ms_based_modifier option
  * Token.t (* "*" *)
  * ms_pointer_modifier list (* zero or more *)
  * type_qualifier list (* zero or more *)
  * declarator
)

and pointer_expression = (
    [ `STAR of Token.t (* "*" *) | `AMP of Token.t (* "&" *) ]
  * expression
)

and pointer_field_declarator = (
    ms_based_modifier option
  * Token.t (* "*" *)
  * ms_pointer_modifier list (* zero or more *)
  * type_qualifier list (* zero or more *)
  * field_declarator
)

and pointer_type_declarator = (
    ms_based_modifier option
  * Token.t (* "*" *)
  * ms_pointer_modifier list (* zero or more *)
  * type_qualifier list (* zero or more *)
  * type_declarator
)

and preproc_elifdef = (
    anon_choice_pat_0307ca2_dbf6a9d
  * identifier (*tok*)
  * block_item list (* zero or more *)
  * anon_choice_prep_else_8b52b0f option
)

and preproc_elifdef_in_enumerator_list = (
    anon_choice_pat_0307ca2_dbf6a9d
  * identifier (*tok*)
  * (enumerator * Token.t (* "," *)) list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_8258275 option
)

and preproc_elifdef_in_enumerator_list_no_comma = (
    anon_choice_pat_0307ca2_dbf6a9d
  * identifier (*tok*)
  * enumerator list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_no_comma_04fd5a5 option
)

and preproc_elifdef_in_field_declaration_list = (
    anon_choice_pat_0307ca2_dbf6a9d
  * identifier (*tok*)
  * field_declaration_list_item list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e option
)

and preproc_if = (
    pat_3df6e71
  * preproc_expression
  * Token.t (* "\n" *)
  * block_item list (* zero or more *)
  * anon_choice_prep_else_8b52b0f option
  * pat_c46d1b2
)

and preproc_if_in_enumerator_list = (
    pat_3df6e71
  * preproc_expression
  * Token.t (* "\n" *)
  * (enumerator * Token.t (* "," *)) list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_8258275 option
  * pat_c46d1b2
)

and preproc_if_in_enumerator_list_no_comma = (
    pat_3df6e71
  * preproc_expression
  * Token.t (* "\n" *)
  * enumerator list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_no_comma_04fd5a5 option
  * pat_c46d1b2
)

and preproc_if_in_field_declaration_list = (
    pat_3df6e71
  * preproc_expression
  * Token.t (* "\n" *)
  * field_declaration_list_item list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e option
  * pat_c46d1b2
)

and preproc_ifdef = (
    anon_choice_pat_25b90ba_4a37f8c
  * identifier (*tok*)
  * block_item list (* zero or more *)
  * [
        `Choice_prep_else of anon_choice_prep_else_8b52b0f
      | `Prep_elif of preproc_elifdef
    ]
      option
  * pat_c46d1b2
)

and preproc_ifdef_in_enumerator_list = (
    anon_choice_pat_25b90ba_4a37f8c
  * identifier (*tok*)
  * (enumerator * Token.t (* "," *)) list (* zero or more *)
  * [
        `Choice_prep_else_in_enum_list of
          anon_choice_prep_else_in_enum_list_8258275
      | `Prep_elif_in_enum_list of preproc_elifdef_in_enumerator_list
    ]
      option
  * pat_c46d1b2
)

and preproc_ifdef_in_enumerator_list_no_comma = (
    anon_choice_pat_25b90ba_4a37f8c
  * identifier (*tok*)
  * enumerator list (* zero or more *)
  * [
        `Choice_prep_else_in_enum_list_no_comma of
          anon_choice_prep_else_in_enum_list_no_comma_04fd5a5
      | `Prep_elif_in_enum_list_no_comma of
          preproc_elifdef_in_enumerator_list_no_comma
    ]
      option
  * pat_c46d1b2
)

and preproc_ifdef_in_field_declaration_list = (
    anon_choice_pat_25b90ba_4a37f8c
  * identifier (*tok*)
  * field_declaration_list_item list (* zero or more *)
  * [
        `Choice_prep_else_in_field_decl_list of
          anon_choice_prep_else_in_field_decl_list_97ea65e
      | `Prep_elif_in_field_decl_list of
          preproc_elifdef_in_field_declaration_list
    ]
      option
  * pat_c46d1b2
)

and qualified_field_identifier = (
    scope_resolution
  * [
        `Depe_field_id of dependent_field_identifier
      | `Qual_field_id of qualified_field_identifier
      | `Temp_meth of template_method
      | `Choice_id of field_identifier
    ]
)

and qualified_identifier = (
    scope_resolution
  * [
        `Depe_id of dependent_identifier
      | `Qual_id of qualified_identifier
      | `Temp_func of template_function
      | `Opt_temp_id of (
            Token.t (* "template" *) option
          * identifier (*tok*)
        )
      | `Op_name of operator_name
      | `Dest_name of destructor_name
      | `Poin_type_decl of pointer_type_declarator
    ]
)

and qualified_operator_cast_identifier = (
    scope_resolution
  * [
        `Qual_op_cast_id of qualified_operator_cast_identifier
      | `Op_cast of operator_cast
    ]
)

and qualified_type_identifier = (
    scope_resolution
  * [
        `Depe_type_id of dependent_type_identifier
      | `Qual_type_id of qualified_type_identifier
      | `Temp_type of template_type
      | `Id of identifier (*tok*)
    ]
)

and requirement = [
    `Exp_stmt of expression_statement
  | `Type_requ of (Token.t (* "typename" *) * class_name)
  | `Comp_requ of (
        Token.t (* "{" *)
      * expression
      * Token.t (* "}" *)
      * Token.t (* "noexcept" *) option
      * trailing_return_type option
      * Token.t (* ";" *)
    )
]

and requirement_clause_constraint = [
    `True of true_ (*tok*)
  | `False of false_ (*tok*)
  | `Class_name of class_name
  | `Fold_exp of fold_expression
  | `Lambda_exp of lambda_expression
  | `Requis_exp of requires_expression
  | `LPAR_exp_RPAR of (Token.t (* "(" *) * expression * Token.t (* ")" *))
  | `Cons_conj of (
        requirement_clause_constraint
      * [ `AMPAMP of Token.t (* "&&" *) | `And of Token.t (* "and" *) ]
      * requirement_clause_constraint
    )
  | `Cons_disj of (
        requirement_clause_constraint
      * [ `BARBAR of Token.t (* "||" *) | `Or of Token.t (* "or" *) ]
      * requirement_clause_constraint
    )
]

and requirement_seq = (
    Token.t (* "{" *)
  * requirement list (* zero or more *)
  * Token.t (* "}" *)
)

and requires_clause = (
    Token.t (* "requires" *) * requirement_clause_constraint
)

and requires_expression = (
    Token.t (* "requires" *)
  * requires_parameter_list option
  * requirement_seq
)

and requires_parameter_list = (
    Token.t (* "(" *)
  * (
        anon_choice_param_decl_1a61eef
      * (Token.t (* "," *) * anon_choice_param_decl_1a61eef)
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

and return_statement = [
    `Ret_opt_choice_exp_SEMI of (
        Token.t (* "return" *)
      * anon_choice_exp_55b4dba option
      * Token.t (* ";" *)
    )
  | `Ret_init_list_SEMI of (
        Token.t (* "return" *) * initializer_list * Token.t (* ";" *)
    )
]

and scope_resolution = (
    [
        `Id of identifier (*tok*)
      | `Temp_type of template_type
      | `Decl of decltype
      | `Depe_type_id of dependent_type_identifier
    ]
      option
  * Token.t (* "::" *)
)

and seh_except_clause = (
    Token.t (* "__except" *) * parenthesized_expression * compound_statement
)

and seh_finally_clause = (Token.t (* "__finally" *) * compound_statement)

and seh_try_statement = (
    Token.t (* "__try" *)
  * compound_statement
  * [
        `Seh_except_clause of seh_except_clause
      | `Seh_fina_clause of seh_finally_clause
    ]
)

and semgrep_typed_metavar = (type_descriptor * semgrep_metavar (*tok*))

and sizeof_expression = [
    `Sizeof_choice_exp of (
        Token.t (* "sizeof" *)
      * [
            `Exp of expression
          | `LPAR_type_desc_RPAR of (
                Token.t (* "(" *) * type_descriptor * Token.t (* ")" *)
            )
        ]
    )
  | `Sizeof_DOTDOTDOT_LPAR_id_RPAR of (
        Token.t (* "sizeof" *) * Token.t (* "..." *) * Token.t (* "(" *)
      * identifier (*tok*) * Token.t (* ")" *)
    )
]

and statement = [
    `Case_stmt of case_statement
  | `Choice_choice_attr_stmt of non_case_statement
]

and static_assert_declaration = (
    Token.t (* "static_assert" *)
  * Token.t (* "(" *)
  * expression
  * (
        Token.t (* "," *)
      * [
            `Str_lit of string_literal
          | `Raw_str_lit of raw_string_literal
          | `Conc_str of concatenated_string
        ]
    )
      option
  * Token.t (* ")" *)
  * Token.t (* ";" *)
)

and subscript_argument_list = (
    Token.t (* "[" *)
  * (
        anon_choice_exp_3078596
      * (Token.t (* "," *) * anon_choice_exp_3078596) list (* zero or more *)
    )
      option
  * Token.t (* "]" *)
)

and subscript_designator = (
    Token.t (* "[" *) * expression * Token.t (* "]" *)
)

and subscript_expression = (expression * subscript_argument_list)

and subscript_range_designator = (
    Token.t (* "[" *) * expression * Token.t (* "..." *) * expression
  * Token.t (* "]" *)
)

and switch_statement = (
    Token.t (* "switch" *) * condition_clause * compound_statement
)

and template_argument_list = (
    Token.t (* "<" *)
  * (
        anon_choice_type_desc_4d9cafa
      * (Token.t (* "," *) * anon_choice_type_desc_4d9cafa)
          list (* zero or more *)
    )
      option
  * tok_prec_p1_gt (*tok*)
)

and template_declaration = (
    Token.t (* "template" *)
  * template_parameter_list
  * requires_clause option
  * [
        `Empty_decl of empty_declaration
      | `Alias_decl of alias_declaration
      | `Decl of declaration
      | `Temp_decl of template_declaration
      | `Func_defi of function_definition
      | `Conc_defi of concept_definition
      | `Friend_decl of friend_declaration
      | `Cons_or_dest_decl of constructor_or_destructor_declaration
      | `Cons_or_dest_defi of constructor_or_destructor_definition
      | `Op_cast_decl of operator_cast_declaration
      | `Op_cast_defi of operator_cast_definition
    ]
)

and template_function = (identifier (*tok*) * template_argument_list)

and template_instantiation = (
    Token.t (* "template" *)
  * declaration_specifiers option
  * declarator
  * Token.t (* ";" *)
)

and template_method = (
    [ `Choice_id of field_identifier | `Op_name of operator_name ]
  * template_argument_list
)

and template_parameter_list = (
    Token.t (* "<" *)
  * (
        anon_choice_param_decl_13b5913
      * (Token.t (* "," *) * anon_choice_param_decl_13b5913)
          list (* zero or more *)
    )
      option
  * tok_prec_p1_gt (*tok*)
)

and template_type = (identifier (*tok*) * template_argument_list)

and throw_statement = (
    Token.t (* "throw" *)
  * expression option
  * Token.t (* ";" *)
)

and trailing_return_type = (Token.t (* "->" *) * type_descriptor)

and try_statement = (
    Token.t (* "try" *)
  * compound_statement
  * catch_clause list (* one or more *)
)

and type_declarator = [
    `Attr_type_decl of (
        type_declarator
      * attribute_declaration list (* one or more *)
    )
  | `Poin_type_decl of pointer_type_declarator
  | `Func_type_decl of (type_declarator * parameter_list)
  | `Array_type_decl of (
        type_declarator
      * Token.t (* "[" *)
      * type_qualifier list (* zero or more *)
      * anon_choice_exp_508611b option
      * Token.t (* "]" *)
    )
  | `Paren_type_decl of (
        Token.t (* "(" *) * type_declarator * Token.t (* ")" *)
    )
  | `Id of identifier (*tok*)
  | `Choice_signed of anon_choice_signed_a0bfc19
  | `Prim_type of primitive_type (*tok*)
]

and type_definition = (
    Token.t (* "__extension__" *) option
  * Token.t (* "typedef" *)
  * type_definition_type
  * type_definition_declarators
  * attribute_specifier list (* zero or more *)
  * Token.t (* ";" *)
)

and type_definition_declarators = (
    type_declarator
  * (Token.t (* "," *) * type_declarator) list (* zero or more *)
)

and type_definition_type = (
    type_qualifier list (* zero or more *)
  * type_specifier
  * type_qualifier list (* zero or more *)
)

and type_descriptor = (
    type_qualifier list (* zero or more *)
  * type_specifier
  * type_qualifier list (* zero or more *)
  * abstract_declarator option
)

and type_specifier = [
    `Struct_spec of (Token.t (* "struct" *) * class_declaration)
  | `Union_spec of (Token.t (* "union" *) * class_declaration)
  | `Enum_spec of (
        Token.t (* "enum" *)
      * [
            `Class of Token.t (* "class" *)
          | `Struct of Token.t (* "struct" *)
        ]
          option
      * [
            `Class_name_opt_enum_base_clause_opt_enum_list of (
                class_name
              * enum_base_clause option
              * enumerator_list option
            )
          | `Enum_list of enumerator_list
        ]
      * attribute_specifier option
    )
  | `Class_spec of (Token.t (* "class" *) * class_declaration)
  | `Sized_type_spec of sized_type_specifier
  | `Prim_type of primitive_type (*tok*)
  | `Temp_type of template_type
  | `Depe_type of (Token.t (* "typename" *) * type_specifier)
  | `Plac_type_spec of (
        type_specifier option
      * [ `Auto of Token.t (* "auto" *) | `Decl_auto of decltype_auto ]
    )
  | `Decl of decltype
  | `Choice_qual_type_id of [
        `Qual_type_id of qualified_type_identifier
      | `Id of identifier (*tok*)
    ]
]

and unary_expression = [
    `Choice_BANG_exp of (anon_choice_BANG_67174d6 * expression)
  | `Choice_not_exp of (
        [ `Not of Token.t (* "not" *) | `Compl of Token.t (* "compl" *) ]
      * expression
    )
]

and unary_left_fold = (Token.t (* "..." *) * fold_operator * expression)

and unary_right_fold = (expression * fold_operator * Token.t (* "..." *))

and update_expression = [
    `Choice_DASHDASH_exp of (anon_choice_DASHDASH_d11def2 * expression)
  | `Exp_choice_DASHDASH of (expression * anon_choice_DASHDASH_d11def2)
]

and using_declaration = (
    Token.t (* "using" *)
  * [ `Name of Token.t (* "namespace" *) | `Enum of Token.t (* "enum" *) ]
      option
  * [ `Id of identifier (*tok*) | `Qual_id of qualified_identifier ]
  * Token.t (* ";" *)
)

and variadic_parameter_declaration = (
    declaration_specifiers
  * [
        `Vari_decl of variadic_declarator
      | `Vari_ref_decl of variadic_reference_declarator
    ]
)

and while_statement = (Token.t (* "while" *) * condition_clause * statement)

type top_level_expression_statement = (
    expression_not_binary * Token.t (* ";" *)
)

type old_style_function_declarator = (declarator * old_style_parameter_list)

type top_level_statement = [
    `Choice_choice_case_stmt of [
        `Choice_case_stmt of [
            `Case_stmt of case_statement
          | `Attr_stmt of attributed_statement
          | `Labe_stmt of labeled_statement
          | `Comp_stmt of compound_statement
          | `Top_level_exp_stmt of top_level_expression_statement
          | `If_stmt of if_statement
          | `Switch_stmt of switch_statement
          | `Do_stmt of do_statement
          | `While_stmt of while_statement
          | `For_stmt of for_statement
          | `Ret_stmt of return_statement
          | `Brk_stmt of break_statement
          | `Cont_stmt of continue_statement
          | `Goto_stmt of goto_statement
        ]
      | `Co_ret_stmt of co_return_statement
      | `Co_yield_stmt of co_yield_statement
      | `For_range_loop of for_range_loop
      | `Try_stmt of try_statement
      | `Throw_stmt of throw_statement
    ]
  | `Semg_ellips of Token.t (* "..." *)
]

type top_level_item = [
    `Func_defi of function_definition
  | `Link_spec of linkage_specification
  | `Decl of declaration
  | `Choice_choice_choice_case_stmt of top_level_statement
  | `Attr_stmt of attributed_statement
  | `Type_defi of type_definition
  | `Empty_decl of empty_declaration
  | `Prep_if of preproc_if
  | `Prep_ifdef of preproc_ifdef
  | `Prep_incl of preproc_include
  | `Prep_def of preproc_def
  | `Prep_func_def of preproc_function_def
  | `Prep_call of preproc_call
  | `Name_defi of namespace_definition
  | `Conc_defi of concept_definition
  | `Name_alias_defi of namespace_alias_definition
  | `Using_decl of using_declaration
  | `Alias_decl of alias_declaration
  | `Static_assert_decl of static_assert_declaration
  | `Temp_decl of template_declaration
  | `Temp_inst of template_instantiation
  | `Cons_or_dest_defi of constructor_or_destructor_definition
  | `Op_cast_defi of operator_cast_definition
  | `Op_cast_decl of operator_cast_declaration
]

type translation_unit = [
    `Rep_choice_func_defi of top_level_item list (* zero or more *)
  | `Semg_exp of (Token.t (* "__SEMGREP_EXPRESSION" *) * expression)
]

type ms_signed_ptr_modifier (* inlined *) = Token.t (* "__sptr" *)

type ms_restrict_modifier (* inlined *) = Token.t (* "__restrict" *)

type ms_unsigned_ptr_modifier (* inlined *) = Token.t (* "__uptr" *)

type auto (* inlined *) = Token.t (* "auto" *)

type this (* inlined *) = Token.t (* "this" *)

type comment (* inlined *) = Token.t

type variadic_parameter (* inlined *) = Token.t (* "..." *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type namespace_identifier (* inlined *) = identifier (*tok*)

type type_identifier (* inlined *) = identifier (*tok*)

type statement_identifier (* inlined *) = identifier (*tok*)

type structured_binding_declarator (* inlined *) = (
    Token.t (* "[" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t (* "]" *)
)

type preproc_parenthesized_expression (* inlined *) = (
    Token.t (* "(" *) * preproc_expression * Token.t (* ")" *)
)

type preproc_unary_expression (* inlined *) = (
    anon_choice_BANG_67174d6 * preproc_expression
)

type array_type_declarator (* inlined *) = (
    type_declarator
  * Token.t (* "[" *)
  * type_qualifier list (* zero or more *)
  * anon_choice_exp_508611b option
  * Token.t (* "]" *)
)

type attributed_type_declarator (* inlined *) = (
    type_declarator
  * attribute_declaration list (* one or more *)
)

type class_specifier (* inlined *) = (
    Token.t (* "class" *) * class_declaration
)

type co_await_expression (* inlined *) = (
    Token.t (* "co_await" *) * expression
)

type compound_requirement (* inlined *) = (
    Token.t (* "{" *)
  * expression
  * Token.t (* "}" *)
  * Token.t (* "noexcept" *) option
  * trailing_return_type option
  * Token.t (* ";" *)
)

type constraint_conjunction (* inlined *) = (
    requirement_clause_constraint
  * [ `AMPAMP of Token.t (* "&&" *) | `And of Token.t (* "and" *) ]
  * requirement_clause_constraint
)

type constraint_disjunction (* inlined *) = (
    requirement_clause_constraint
  * [ `BARBAR of Token.t (* "||" *) | `Or of Token.t (* "or" *) ]
  * requirement_clause_constraint
)

type deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

type delete_expression (* inlined *) = (
    Token.t (* "::" *) option
  * Token.t (* "delete" *)
  * (Token.t (* "[" *) * Token.t (* "]" *)) option
  * expression
)

type dependent_type (* inlined *) = (
    Token.t (* "typename" *) * type_specifier
)

type enum_specifier (* inlined *) = (
    Token.t (* "enum" *)
  * [ `Class of Token.t (* "class" *) | `Struct of Token.t (* "struct" *) ]
      option
  * [
        `Class_name_opt_enum_base_clause_opt_enum_list of (
            class_name
          * enum_base_clause option
          * enumerator_list option
        )
      | `Enum_list of enumerator_list
    ]
  * attribute_specifier option
)

type function_type_declarator (* inlined *) = (
    type_declarator * parameter_list
)

type inline_method_definition (* inlined *) = (
    declaration_specifiers
  * field_declarator
  * [
        `Choice_comp_stmt of anon_choice_comp_stmt_e6a11e2
      | `Defa_meth_clause of default_method_clause
      | `Delete_meth_clause of delete_method_clause
    ]
)

type new_expression (* inlined *) = (
    Token.t (* "::" *) option
  * Token.t (* "new" *)
  * argument_list option
  * type_specifier
  * new_declarator option
  * anon_choice_arg_list_e4b6f8f option
)

type noexcept (* inlined *) = (
    Token.t (* "noexcept" *)
  * (Token.t (* "(" *) * expression option * Token.t (* ")" *)) option
)

type parameter_pack_expansion (* inlined *) = (
    expression * Token.t (* "..." *)
)

type parenthesized_type_declarator (* inlined *) = (
    Token.t (* "(" *) * type_declarator * Token.t (* ")" *)
)

type placeholder_type_specifier (* inlined *) = (
    type_specifier option
  * [ `Auto of Token.t (* "auto" *) | `Decl_auto of decltype_auto ]
)

type preproc_elif (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * Token.t (* "\n" *)
  * block_item list (* zero or more *)
  * anon_choice_prep_else_8b52b0f option
)

type preproc_elif_in_enumerator_list (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * Token.t (* "\n" *)
  * (enumerator * Token.t (* "," *)) list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_8258275 option
)

type preproc_elif_in_enumerator_list_no_comma (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * Token.t (* "\n" *)
  * enumerator list (* zero or more *)
  * anon_choice_prep_else_in_enum_list_no_comma_04fd5a5 option
)

type preproc_elif_in_field_declaration_list (* inlined *) = (
    pat_bfeb4bb
  * preproc_expression
  * Token.t (* "\n" *)
  * field_declaration_list_item list (* zero or more *)
  * anon_choice_prep_else_in_field_decl_list_97ea65e option
)

type preproc_else (* inlined *) = (
    pat_56631e5
  * block_item list (* zero or more *)
)

type preproc_else_in_enumerator_list (* inlined *) = (
    pat_56631e5
  * (enumerator * Token.t (* "," *)) list (* zero or more *)
)

type preproc_else_in_enumerator_list_no_comma (* inlined *) = (
    pat_56631e5
  * enumerator list (* zero or more *)
)

type preproc_else_in_field_declaration_list (* inlined *) = (
    pat_56631e5
  * field_declaration_list_item list (* zero or more *)
)

type reference_declarator (* inlined *) = (ref_qualifier * declarator)

type reference_field_declarator (* inlined *) = (
    ref_qualifier * field_declarator
)

type struct_specifier (* inlined *) = (
    Token.t (* "struct" *) * class_declaration
)

type template_template_parameter_declaration (* inlined *) = (
    Token.t (* "template" *)
  * template_parameter_list
  * [
        `Type_param_decl of type_parameter_declaration
      | `Vari_type_param_decl of variadic_type_parameter_declaration
      | `Opt_type_param_decl of optional_type_parameter_declaration
    ]
)

type throw_specifier (* inlined *) = (
    Token.t (* "throw" *)
  * Token.t (* "(" *)
  * (
        type_descriptor
      * (Token.t (* "," *) * type_descriptor) list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type type_parameter_pack_expansion (* inlined *) = (
    type_descriptor * Token.t (* "..." *)
)

type type_requirement (* inlined *) = (Token.t (* "typename" *) * class_name)

type union_specifier (* inlined *) = (
    Token.t (* "union" *) * class_declaration
)

type semgrep_expression (* inlined *) = (
    Token.t (* "__SEMGREP_EXPRESSION" *) * expression
)

type macro_type_specifier (* inlined *) = (
    identifier (*tok*) * Token.t (* "(" *) * type_descriptor
  * Token.t (* ")" *)
)

type field_declaration_declarator (* inlined *) = (
    field_declarator
  * bitfield_clause option
  * (Token.t (* "," *) * field_declarator * bitfield_clause option)
      list (* zero or more *)
)

type old_style_function_definition (* inlined *) = (
    ms_call_modifier option
  * declaration_specifiers
  * old_style_function_declarator
  * declaration list (* zero or more *)
  * compound_statement
)

type extra = Comment of Loc.t * comment

type extras = extra list
